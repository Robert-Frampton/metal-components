{"version":3,"sources":["IncrementalDomRenderer.js"],"names":["IncrementalDomRenderer","comp","context","refs","config_","getInitialConfig","childComponents_","clearChanges_","on","handleAttached_","bind","handleInterceptedAttributesCall_","handleInterceptedCloseCall_","handleInterceptedOpenCall_","handleChildrenCaptured_","handleChildRender_","renderInsidePatchDontSkip_","elementClasses","args","i","length","removeDuplicateClasses_","push","node","component_","wasRendered","attrs","concat","slice","eventName","getEventFromListenerAttr_","attachEvent_","element","key","fn","handleKey","removeListener","isString","setAttribute","getListenerFn","delegate","document","removeAttribute","children","emptyChildren_","changes_","ref","owner","getOwner","components","child","isDisposed","dispose","attr","matches","LISTENER_REGEX","exec","toLowerCase","owner_","parent_","config","compatData","getCompatibilityModeData","renderers","useKey","indexOf","constructor","RENDERER_NAME","tagOrCtor","opt_owner","Ctor","getConstructor","getRef_","data","getCurrentData","isDef","match_","addSubComponent","prevComps","keys","currComps","type","getUid","order","parentNode","parent","createElement","append","attachData_","tree","componentToRender_","props","tag","buildChildren_","renderFromTag_","isComponentTag","getComponent","manager","getDataManager","SYNC_UPDATES_MERGED","handleDataPropChanged_","add","validator","Array","isArray","value","originalFn","name","isDefAndNotNull","isBoolean","emit","ELEMENT_CLOSED","resetData_","get","incDomData_","handleSubComponentCall_","apply","arguments","handleRegularCall_","ELEMENT_OPENED","currComp","getComponentBeingRendered","currRenderer","getRenderer","rootElementReached_","addElementClasses_","attachDecoratedListeners_","updateElementIfNotReached_","buildConfigFromCall","capture","Object","startInterception","attributes","elementClose","elementOpen","isMatch_","startSkipUpdates","replaceNonInternal","stopSkipUpdates","patch","tempParent","guaranteeParent_","IncrementalDOM","exitDocument","inDocument","renderElement_","sibling","patchOuter","cssClasses","noDuplicates","all","split","used","join","intercept_","render","stopInterception","prototype","renderSubComponent_","elementVoid","shouldUpdate","currentPointer","skipNode","startedRenderingComponent","schedule","renderIncDom","isRendered_","finishedRenderingComponent","getSubComponent_","updateContext_","renderer","parentComp","parentRenderer","renderInsidePatch","console","warn","renderAsSubComponent","hasDataChanged_","buildShouldUpdateArgs_","childContext","getChildContext","mixin","renderingComponents_","pop","disposeUnused","currentElement","obj","CHILD_OWNER","fnOrCtor","opt_dataOrElement","opt_parent","isComponentCtor","TempComponent","RENDERER","renderChild"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAeMA,sB;;;AACL;;;AAGA,kCAAYC,IAAZ,EAAkB;AAAA;;AAAA,+IACXA,IADW;;AAGjBA,QAAKC,OAAL,GAAe,EAAf;AACAD,QAAKE,IAAL,GAAY,EAAZ;AACA,SAAKC,OAAL,GAAeH,KAAKI,gBAAL,EAAf;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,aAAL;AACAN,QAAKO,EAAL,CAAQ,UAAR,EAAoB,MAAKC,eAAL,CAAqBC,IAArB,OAApB;;AAEA;AACA;AACA,SAAKC,gCAAL,GACC,MAAKA,gCAAL,CAAsCD,IAAtC,OADD;AAEA,SAAKE,2BAAL,GACC,MAAKA,2BAAL,CAAiCF,IAAjC,OADD;AAEA,SAAKG,0BAAL,GACC,MAAKA,0BAAL,CAAgCH,IAAhC,OADD;AAEA,SAAKI,uBAAL,GAA+B,MAAKA,uBAAL,CAA6BJ,IAA7B,OAA/B;AACA,SAAKK,kBAAL,GAA0B,MAAKA,kBAAL,CAAwBL,IAAxB,OAA1B;AACA,SAAKM,0BAAL,GAAkC,MAAKA,0BAAL,CAAgCN,IAAhC,OAAlC;AApBiB;AAqBjB;;AAED;;;;;;;;;;;sCAOmBO,c,EAAgBC,I,EAAM;AACxC,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,KAAKE,MAAzB,EAAiCD,KAAK,CAAtC,EAAyC;AACxC,SAAID,KAAKC,CAAL,MAAY,OAAhB,EAAyB;AACxBD,WAAKC,IAAI,CAAT,IAAc,KAAKE,uBAAL,CACbH,KAAKC,IAAI,CAAT,IAAc,GAAd,GAAoBF,cADP,CAAd;AAGA;AACA;AACD;AACD,WAAOC,KAAKE,MAAL,GAAc,CAArB,EAAwB;AACvBF,UAAKI,IAAL,CAAU,IAAV;AACA;AACDJ,SAAKI,IAAL,CAAU,OAAV,EAAmBL,cAAnB;AACA;;;6CAYyBM,I,EAAML,I,EAAM;AACrC,QAAI,CAAC,KAAKM,UAAL,CAAgBC,WAArB,EAAkC;AACjC,SAAIC,QAAQ,CAACR,KAAK,CAAL,KAAW,EAAZ,EAAgBS,MAAhB,CAAuBT,KAAKU,KAAL,CAAW,CAAX,CAAvB,CAAZ;AACA,UAAK,IAAIT,IAAI,CAAb,EAAgBA,IAAIO,MAAMN,MAA1B,EAAkCD,KAAK,CAAvC,EAA0C;AACzC,UAAIU,YAAY,KAAKC,yBAAL,CAA+BJ,MAAMP,CAAN,CAA/B,CAAhB;AACA,UAAIU,aAAa,CAACN,KAAKM,YAAY,YAAjB,CAAlB,EAAkD;AACjD,YAAKE,YAAL,CAAkBR,IAAlB,EAAwBG,MAAMP,CAAN,CAAxB,EAAkCU,SAAlC,EAA6CH,MAAMP,IAAI,CAAV,CAA7C;AACA;AACD;AACD;AACD;;;gCAUYa,O,EAASC,G,EAAKJ,S,EAAWK,E,EAAI;AACzC,QAAIC,YAAYN,YAAY,YAA5B;AACA,QAAIG,QAAQG,SAAR,CAAJ,EAAwB;AACvBH,aAAQG,SAAR,EAAmBC,cAAnB;AACAJ,aAAQG,SAAR,IAAqB,IAArB;AACA;;AAEDH,YAAQC,GAAR,IAAeC,EAAf;AACA,QAAIA,EAAJ,EAAQ;AACP,SAAI,YAAKG,QAAL,CAAcH,EAAd,CAAJ,EAAuB;AACtB,UAAID,IAAI,CAAJ,MAAW,GAAf,EAAoB;AACnB;AACA;AACAD,eAAQM,YAAR,CAAqBL,GAArB,EAA0BC,EAA1B;AACA;AACDA,WAAK,KAAKV,UAAL,CAAgBe,aAAhB,CAA8BL,EAA9B,CAAL;AACA;AACDF,aAAQG,SAAR,IAAqB,cAAIK,QAAJ,CAAaC,QAAb,EAAuBZ,SAAvB,EAAkCG,OAAlC,EAA2CE,EAA3C,CAArB;AACA,KAVD,MAUO;AACNF,aAAQU,eAAR,CAAwBT,GAAxB;AACA;AACD;;;kCAQcU,Q,EAAU;AACxB,WAAOA,SAASvB,MAAT,KAAoB,CAApB,GAAwBwB,cAAxB,GAAyCD,QAAhD;AACA;;;4CASwB;AACxB,WAAO,CAAC,KAAKE,QAAN,CAAP;AACA;;;mCAMe;AACf,SAAKA,QAAL,GAAgB,EAAhB;AACA;;;qCAKiB;AACjB;;AAEA,QAAI5C,OAAO,KAAKuB,UAAhB;AACA,QAAIsB,MAAM,KAAK1C,OAAL,CAAa0C,GAAvB;AACA,QAAIC,QAAQ,KAAKC,QAAL,EAAZ;AACA,QAAID,SAASA,MAAME,UAAf,IAA6BF,MAAME,UAAN,CAAiBH,GAAjB,MAA0B7C,IAA3D,EAAiE;AAChE,YAAO8C,MAAME,UAAN,CAAiBH,GAAjB,CAAP;AACA;;AAED,SAAK,IAAI3B,IAAI,CAAb,EAAgBA,IAAI,KAAKb,gBAAL,CAAsBc,MAA1C,EAAkDD,GAAlD,EAAuD;AACtD,SAAM+B,QAAQ,KAAK5C,gBAAL,CAAsBa,CAAtB,CAAd;AACA,SAAI,CAAC+B,MAAMC,UAAN,EAAL,EAAyB;AACxBD,YAAMlB,OAAN,GAAgB,IAAhB;AACAkB,YAAME,OAAN;AACA;AACD;AACD,SAAK9C,gBAAL,GAAwB,IAAxB;AACA;;;6CAuDyB+C,I,EAAM;AAC/B,QAAIC,UAAUtD,uBAAuBuD,cAAvB,CAAsCC,IAAtC,CAA2CH,IAA3C,CAAd;AACA,QAAIxB,YAAYyB,UAAWA,QAAQ,CAAR,IAAaA,QAAQ,CAAR,CAAb,GAA0BA,QAAQ,CAAR,CAArC,GAAmD,IAAnE;AACA,WAAOzB,YAAYA,UAAU4B,WAAV,EAAZ,GAAsC,IAA7C;AACA;;;8BAOU;AACV,WAAO,KAAKC,MAAZ;AACA;;;+BAOW;AACX,WAAO,KAAKC,OAAZ;AACA;;;2BASOC,M,EAAQ;AACf,QAAMC,aAAa,YAAKC,wBAAL,EAAnB;AACA,QAAID,UAAJ,EAAgB;AACf,SAAME,YAAYF,WAAWE,SAA7B;AACA,SAAMC,SAAS,CAACD,SAAD,IACdA,UAAUE,OAAV,CAAkB,KAAKC,WAAvB,MAAwC,CAAC,CAD3B,IAEdH,UAAUE,OAAV,CAAkB,KAAKC,WAAL,CAAiBC,aAAnC,MAAsD,CAAC,CAFxD;AAGA,SAAIH,UAAUJ,OAAO3B,GAAjB,IAAwB,CAAC2B,OAAOd,GAApC,EAAyC;AACxC,aAAOc,OAAO3B,GAAd;AACA;AACD;AACD,WAAO2B,OAAOd,GAAd;AACA;;;oCAWgBsB,S,EAAWR,M,EAAQS,S,EAAW;AAC9C,QAAIC,OAAOF,SAAX;AACA,QAAI,YAAK/B,QAAL,CAAciC,IAAd,CAAJ,EAAyB;AACxBA,YAAO,6BAAkBC,cAAlB,CAAiCH,SAAjC,CAAP;AACA;;AAED,QAAMtB,MAAM,KAAK0B,OAAL,CAAaZ,MAAb,CAAZ;AACA,QAAIa,OAAOzE,uBAAuB0E,cAAvB,EAAX;AACA,QAAIzE,IAAJ;AACA,QAAI,YAAK0E,KAAL,CAAW7B,GAAX,CAAJ,EAAqB;AACpB,SAAMC,QAAQsB,aAAa,KAAK7C,UAAhC;AACAvB,YAAO,KAAK2E,MAAL,CAAY7B,MAAME,UAAN,CAAiBH,GAAjB,CAAZ,EAAmCwB,IAAnC,EAAyCV,MAAzC,CAAP;AACAb,WAAM8B,eAAN,CAAsB/B,GAAtB,EAA2B7C,IAA3B;AACA8C,WAAM5C,IAAN,CAAW2C,GAAX,IAAkB7C,IAAlB;AACA,KALD,MAKO,IAAI,YAAK0E,KAAL,CAAWf,OAAO3B,GAAlB,CAAJ,EAA4B;AAClChC,YAAO,KAAK2E,MAAL,CAAYH,KAAKK,SAAL,CAAeC,IAAf,CAAoBnB,OAAO3B,GAA3B,CAAZ,EAA6CqC,IAA7C,EAAmDV,MAAnD,CAAP;AACAa,UAAKO,SAAL,CAAeD,IAAf,CAAoBnB,OAAO3B,GAA3B,IAAkChC,IAAlC;AACA,KAHM,MAGA;AACN,SAAIgF,OAAO,YAAKC,MAAL,CAAYZ,IAAZ,EAAkB,IAAlB,CAAX;AACAG,UAAKO,SAAL,CAAeG,KAAf,CAAqBF,IAArB,IAA6BR,KAAKO,SAAL,CAAeG,KAAf,CAAqBF,IAArB,KAA8B,EAA3D;AACA,SAAIE,QAAQV,KAAKO,SAAL,CAAeG,KAAf,CAAqBF,IAArB,CAAZ;AACAhF,YAAO,KAAK2E,MAAL,CAAY,CAACH,KAAKK,SAAL,CAAeK,KAAf,CAAqBF,IAArB,KAA8B,EAA/B,EAAmCE,MAAM/D,MAAzC,CAAZ,EAA8DkD,IAA9D,EAAoEV,MAApE,CAAP;AACAuB,WAAM7D,IAAN,CAAWrB,IAAX;AACA;;AAED,WAAOA,IAAP;AACA;;;sCASkB;AAClB,QAAI+B,UAAU,KAAKR,UAAL,CAAgBQ,OAA9B;AACA,QAAI,CAACA,OAAD,IAAY,CAACA,QAAQoD,UAAzB,EAAqC;AACpC,SAAIC,SAAS5C,SAAS6C,aAAT,CAAuB,KAAvB,CAAb;AACA,SAAItD,OAAJ,EAAa;AACZ,oBAAIuD,MAAJ,CAAWF,MAAX,EAAmBrD,OAAnB;AACA;AACD,YAAOqD,MAAP;AACA;AACD;;;mCAOeZ,I,EAAM;AACrB,SAAKe,WAAL,GAAmBf,IAAnB;AACA;;;2CAOuBgB,I,EAAM;AAAA,8BACV,KAAKC,kBADK;AAAA,QACxBC,KADwB,uBACxBA,KADwB;AAAA,QACjBC,GADiB,uBACjBA,GADiB;;AAE7BD,UAAMhD,QAAN,GAAiB,KAAKkD,cAAL,CAAoBJ,KAAKE,KAAL,CAAWhD,QAA/B,CAAjB;AACA,SAAK+C,kBAAL,GAA0B,IAA1B;AACA,SAAKI,cAAL,CAAoBF,GAApB,EAAyBD,KAAzB;AACA;;;sCAUkBpE,I,EAAM;AACxB,QAAIA,KAAKqE,GAAL,IAAY,8BAAoBG,cAApB,CAAmCxE,KAAKqE,GAAxC,CAAhB,EAA8D;AAC7DrE,UAAKoE,KAAL,CAAWhD,QAAX,GAAsB,KAAKkD,cAAL,CAAoBtE,KAAKoE,KAAL,CAAWhD,QAA/B,CAAtB;AACA,SAAMI,QAAQ,iCAAuBC,QAAvB,CAAgCzB,IAAhC,CAAd;AACA,UAAKuE,cAAL,CACCvE,KAAKqE,GADN,EAECrE,KAAKoE,KAFN,EAGC5C,SAASA,MAAMiD,YAAN,EAHV;AAKA,YAAO,IAAP;AACA;AACD;;;+CAK2B;AAC3B;;AAEA,QAAIC,UAAU,KAAKzE,UAAL,CAAgB0E,cAAhB,EAAd;AACA,QAAI,CAAC,KAAK1E,UAAL,CAAgB0C,WAAhB,CAA4BiC,mBAAjC,EAAsD;AACrD;AACA;AACA;AACAF,aAAQzF,EAAR,CAAW,iBAAX,EAA8B,KAAK4F,sBAAL,CAA4B1F,IAA5B,CAAiC,IAAjC,CAA9B;AACA;;AAEDuF,YAAQI,GAAR,CACC,UADD,EAEC;AACCC,gBAAWC,MAAMC,OADlB;AAECC,YAAO7D;AAFR,KAFD,EAMC,KAAKxC,OAAL,CAAauC,QAAb,IAAyBC,cAN1B;AAQA;;;0CAQsB6B,I,EAAM;AAC5B,SAAK5B,QAAL,CAAc4B,KAAKxC,GAAnB,IAA0BwC,IAA1B;AACA;;;oDAWgCiC,U,EAAY1E,O,EAAS2E,I,EAAMF,K,EAAO;AAClE,QAAI5E,YAAY,KAAKC,yBAAL,CAA+B6E,IAA/B,CAAhB;AACA,QAAI9E,SAAJ,EAAe;AACd,UAAKE,YAAL,CAAkBC,OAAlB,EAA2B2E,IAA3B,EAAiC9E,SAAjC,EAA4C4E,KAA5C;AACA;AACA;;AAED,QAAIE,SAAS,SAAb,EAAwB;AACvB;AACA;AACA;AACA;AACAF,aAAQ,YAAKG,eAAL,CAAqBH,KAArB,KAA+BA,UAAU,KAAjD;AACA;;AAED,QAAIE,SAAS,OAAT,IAAoB3E,QAAQyE,KAAR,KAAkBA,KAA1C,EAAiD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACAzE,aAAQ2E,IAAR,IAAgBF,KAAhB;AACA;;AAED,QAAI,YAAKI,SAAL,CAAeJ,KAAf,CAAJ,EAA2B;AAC1B;AACA;AACA;AACAzE,aAAQ2E,IAAR,IAAgBF,KAAhB;AACA,SAAIA,KAAJ,EAAW;AACVzE,cAAQM,YAAR,CAAqBqE,IAArB,EAA2B,EAA3B;AACA,MAFD,MAEO;AACN3E,cAAQU,eAAR,CAAwBiE,IAAxB;AACA;AACD,KAVD,MAUO;AACND,gBAAW1E,OAAX,EAAoB2E,IAApB,EAA0BF,KAA1B;AACA;AACD;;;+CAS2BC,U,EAAYd,G,EAAK;AAC5C,SAAKkB,IAAL,CAAU9G,uBAAuB+G,cAAjC,EAAiD,EAACnB,QAAD,EAAjD;AACA,QAAI5D,UAAU0E,WAAWd,GAAX,CAAd;AACA,SAAKoB,UAAL,CAAgB,aAAQC,GAAR,CAAYjF,OAAZ,EAAqBkF,WAArC;AACA,WAAOlF,OAAP;AACA;;;8CAS0B0E,U,EAAYd,G,EAAK;AAC3C,QAAI,8BAAoBG,cAApB,CAAmCH,GAAnC,CAAJ,EAA6C;AAC5C,YAAO,KAAKuB,uBAAL,CAA6BC,KAA7B,CAAmC,IAAnC,EAAyCC,SAAzC,CAAP;AACA,KAFD,MAEO;AACN,YAAO,KAAKC,kBAAL,CAAwBF,KAAxB,CAA8B,IAA9B,EAAoCC,SAApC,CAAP;AACA;AACD;;;iDAU6B5C,I,EAAM;AACnC,SAAK2B,sBAAL,CAA4B3B,IAA5B;AACA,kKAAoCA,IAApC;AACA;;;sCASkBiC,U,EAAqB;AAAA,sCAANxF,IAAM;AAANA,SAAM;AAAA;;AACvC,SAAK4F,IAAL,CAAU9G,uBAAuBuH,cAAjC,EAAiD,EAACrG,UAAD,EAAjD;AACA,QAAIsG,WAAWxH,uBAAuByH,yBAAvB,EAAf;AACA,QAAIC,eAAeF,SAASG,WAAT,EAAnB;AACA,QAAI,CAACD,aAAaE,mBAAlB,EAAuC;AACtC,SAAIF,aAAatH,OAAb,CAAqB6B,GAAzB,EAA8B;AAC7Bf,WAAK,CAAL,IAAUwG,aAAatH,OAAb,CAAqB6B,GAA/B;AACA;AACD,SAAIhB,iBAAiBuG,SAAStB,cAAT,GAA0Be,GAA1B,CAA8B,gBAA9B,CAArB;AACA,SAAIhG,cAAJ,EAAoB;AACnB,WAAK4G,kBAAL,CAAwB5G,cAAxB,EAAwCC,IAAxC;AACA;AACD;;AAGD,QAAIK,OAAOmF,WAAWU,KAAX,CAAiB,IAAjB,EAAuBlG,IAAvB,CAAX;AACA,SAAK4G,yBAAL,CAA+BvG,IAA/B,EAAqCL,IAArC;AACA,SAAK6G,0BAAL,CAAgCxG,IAAhC;;AAEA,QAAMqC,SAAS,8BAAoBoE,mBAApB,CAAwC9G,IAAxC,CAAf;AACA,QAAI,YAAK0F,eAAL,CAAqBhD,OAAOd,GAA5B,CAAJ,EAAsC;AACrC,UAAKtB,UAAL,CAAgBrB,IAAhB,CAAqByD,OAAOd,GAA5B,IAAmCvB,IAAnC;AACA;AACD,WAAOA,IAAP;AACA;;;2CASuBmF,U,EAAqB;AAAA,uCAANxF,IAAM;AAANA,SAAM;AAAA;;AAC5C,QAAIyE,QAAQ,8BAAoBqC,mBAApB,CAAwC9G,IAAxC,CAAZ;AACA,SAAKwE,kBAAL,GAA0B;AACzBC,iBADyB;AAEzBC,UAAK1E,KAAK,CAAL;AAFoB,KAA1B;AAIA,qCAAuB+G,OAAvB,CAA+B,IAA/B,EAAqC,KAAKnH,uBAA1C;AACA;;;qCAOiB;AACjB,WAAOoH,OAAOnD,IAAP,CAAY,KAAKlC,QAAjB,EAA2BzB,MAA3B,GAAoC,CAA3C;AACA;;;gCAMY;AACZ,gCAAkB+G,iBAAlB,CAAoC;AACnCC,iBAAY,KAAKzH,gCADkB;AAEnC0H,mBAAc,KAAKzH,2BAFgB;AAGnC0H,kBAAa,KAAKzH;AAHiB,KAApC;AAKA;;;4BAkBQZ,I,EAAMqE,I,EAAM;AACpB,QAAI,CAACrE,IAAD,IAASA,KAAKiE,WAAL,KAAqBI,IAA9B,IAAsCrE,KAAKkD,UAAL,EAA1C,EAA6D;AAC5D,YAAO,KAAP;AACA;AACD,WAAOlD,KAAK0H,WAAL,GAAmB3E,QAAnB,OAAkC,KAAKxB,UAA9C;AACA;;;0BAYMvB,I,EAAMqE,I,EAAMV,M,EAAQ;AAC1B,QAAI,CAAC,KAAK2E,QAAL,CAActI,IAAd,EAAoBqE,IAApB,CAAL,EAAgC;AAC/BrE,YAAO,IAAIqE,IAAJ,CAASV,MAAT,EAAiB,KAAjB,CAAP;AACA;AACD,QAAI3D,KAAKwB,WAAT,EAAsB;AACrBxB,UAAK0H,WAAL,GAAmBa,gBAAnB;AACAvI,UAAKiG,cAAL,GAAsBuC,kBAAtB,CAAyC7E,MAAzC;AACA3D,UAAK0H,WAAL,GAAmBe,eAAnB;AACA;AACDzI,SAAK0H,WAAL,GAAmBvH,OAAnB,GAA6BwD,MAA7B;AACA,WAAO3D,IAAP;AACA;;;2BAMO;AACP,QAAI,CAAC,KAAKuB,UAAL,CAAgBQ,OAAjB,IAA4B,KAAK2B,OAArC,EAA8C;AAC7C;AACA;AACA;AACA,UAAKA,OAAL,CAAagE,WAAb,GAA2BgB,KAA3B;AACA;AACA;;AAED,QAAIC,aAAa,KAAKC,gBAAL,EAAjB;AACA,QAAID,UAAJ,EAAgB;AACfE,oBAAeH,KAAf,CAAqBC,UAArB,EAAiC,KAAK5H,0BAAtC;AACA,mBAAI+H,YAAJ,CAAiB,KAAKvH,UAAL,CAAgBQ,OAAjC;AACA,SAAI,KAAKR,UAAL,CAAgBQ,OAAhB,IAA2B,KAAKR,UAAL,CAAgBwH,UAA/C,EAA2D;AAC1D,WAAKxH,UAAL,CAAgByH,cAAhB,CACC,KAAKzD,WAAL,CAAiBH,MADlB,EAEC,KAAKG,WAAL,CAAiB0D,OAFlB;AAIA;AACD,KATD,MASO;AACN,SAAMlH,UAAU,KAAKR,UAAL,CAAgBQ,OAAhC;AACA8G,oBAAeK,UAAf,CAA0BnH,OAA1B,EAAmC,KAAKhB,0BAAxC;AACA;AACD;;;2CAQuBoI,U,EAAY;AACnC,QAAIC,eAAe,EAAnB;AACA,QAAIC,MAAMF,WAAWG,KAAX,CAAiB,KAAjB,CAAV;AACA,QAAIC,OAAO,EAAX;AACA,SAAK,IAAIrI,IAAI,CAAb,EAAgBA,IAAImI,IAAIlI,MAAxB,EAAgCD,GAAhC,EAAqC;AACpC,SAAI,CAACqI,KAAKF,IAAInI,CAAJ,CAAL,CAAL,EAAmB;AAClBqI,WAAKF,IAAInI,CAAJ,CAAL,IAAe,IAAf;AACAkI,mBAAa/H,IAAb,CAAkBgI,IAAInI,CAAJ,CAAlB;AACA;AACD;AACD,WAAOkI,aAAaI,IAAb,CAAkB,GAAlB,CAAP;AACA;;;4BAoCQ;AACR,SAAKd,KAAL;AACA;;;+BAcWzF,K,EAAO;AAClB,SAAKwG,UAAL;AACA,qCAAuBC,MAAvB,CAA8BzG,KAA9B,EAAqC,KAAKnC,kBAA1C;AACA,gCAAkB6I,gBAAlB;AACA;;;kCASchE,G,EAAKhC,M,EAAQS,S,EAAW;AACtC,QAAI,YAAKhC,QAAL,CAAcuD,GAAd,KAAsBA,IAAIiE,SAAJ,CAAclC,WAAxC,EAAqD;AACpD,SAAI1H,OAAO,KAAK6J,mBAAL,CAAyBlE,GAAzB,EAA8BhC,MAA9B,EAAsCS,SAAtC,CAAX;AACA,UAAK0D,0BAAL,CAAgC9H,KAAK+B,OAArC;AACA,YAAO/B,KAAK+B,OAAZ;AACA,KAJD,MAIO;AACN,YAAO4D,IAAIhC,MAAJ,CAAP;AACA;AACD;;;kCAOc;AACd,QAAI,KAAKpC,UAAL,CAAgBmI,MAApB,EAA4B;AAC3B,UAAKnI,UAAL,CAAgBmI,MAAhB;AACA,KAFD,MAEO;AACNb,oBAAeiB,WAAf,CAA2B,KAA3B;AACA;AACD;;;uCAOmB;AACnB,QAAI,KAAKvI,UAAL,CAAgBC,WAAhB,IACH,CAAC,KAAKuI,YAAL,EADE,IAEHlB,eAAemB,cAAf,OAAoC,KAAKzI,UAAL,CAAgBQ,OAFrD,EAE8D;AAC7D,SAAI,KAAKR,UAAL,CAAgBQ,OAApB,EAA6B;AAC5B8G,qBAAeoB,QAAf;AACA;AACD;AACA;AACD,SAAKlJ,0BAAL;AACA;;;gDAO4B;AAC5BhB,2BAAuBmK,yBAAvB,CAAiD,KAAK3I,UAAtD;AACA,SAAKjB,aAAL;AACA,SAAKqH,mBAAL,GAA2B,KAA3B;AACA,6CAA+BwC,QAA/B,CAAwC,KAAK9J,gBAA7C;AACA,SAAKA,gBAAL,GAAwB,EAAxB;AACA,SAAKkB,UAAL,CAAgBrB,IAAhB,GAAuB,EAAvB;AACA,SAAKuJ,UAAL;AACA,SAAKW,YAAL;AACA,gCAAkBT,gBAAlB;AACA,QAAI,CAAC,KAAKhC,mBAAV,EAA+B;AAC9B,UAAKpG,UAAL,CAAgBQ,OAAhB,GAA0B,IAA1B;AACA;AACD,SAAK8E,IAAL,CAAU,UAAV,EAAsB,CAAC,KAAKwD,WAA5B;AACAtK,2BAAuBuK,0BAAvB;AACA,SAAKvD,UAAL,CAAgB,KAAKE,WAArB;AACA;;;uCAamB9C,S,EAAWR,M,EAAQS,S,EAAW;AACjD,QAAIpE,OAAO,KAAKuK,gBAAL,CAAsBpG,SAAtB,EAAiCR,MAAjC,EAAyCS,SAAzC,CAAX;AACA,SAAKoG,cAAL,CAAoBxK,IAApB;AACA,QAAIyK,WAAWzK,KAAK0H,WAAL,EAAf;AACA,QAAI+C,oBAAoB1K,sBAAxB,EAAgD;AAC/C,SAAM2K,aAAa3K,uBAAuByH,yBAAvB,EAAnB;AACA,SAAMmD,iBAAiBD,WAAWhD,WAAX,EAAvB;AACAiD,oBAAetK,gBAAf,CAAgCgB,IAAhC,CAAqCrB,IAArC;AACAyK,cAAS/G,OAAT,GAAmBgH,UAAnB;AACAD,cAAShH,MAAT,GAAkBW,aAAa,KAAK7C,UAApC;AACA,SAAI,CAACoC,OAAO3B,GAAR,IAAe,CAAC2I,eAAehD,mBAAnC,EAAwD;AACvDhE,aAAO3B,GAAP,GAAa2I,eAAexK,OAAf,CAAuB6B,GAApC;AACA;AACDyI,cAASG,iBAAT;AACA,KAVD,MAUO;AACNC,aAAQC,IAAR,CACC,sEACA,uDAFD,EAGC9K,IAHD;AAKA;AACD,QAAI,CAACA,KAAKwB,WAAV,EAAuB;AACtBxB,UAAK+K,oBAAL;AACA;AACD,WAAO/K,IAAP;AACA;;;8BAQUwE,I,EAAM;AAChB,QAAIA,IAAJ,EAAU;AACTA,UAAKK,SAAL,CAAeC,IAAf,GAAsBN,KAAKO,SAAL,CAAeD,IAArC;AACAN,UAAKK,SAAL,CAAeK,KAAf,GAAuBV,KAAKO,SAAL,CAAeG,KAAtC;AACAV,UAAKO,SAAL,CAAeD,IAAf,GAAsB,EAAtB;AACAN,UAAKO,SAAL,CAAeG,KAAf,GAAuB,EAAvB;AACA;AACD;;;kCASc;AACd,QAAI,CAAC,KAAK8F,eAAL,EAAL,EAA6B;AAC5B,YAAO,KAAP;AACA;AACD,QAAI,KAAKzJ,UAAL,CAAgBwI,YAApB,EAAkC;AAAA;;AACjC,YAAO,oBAAKxI,UAAL,EAAgBwI,YAAhB,uCAAgC,KAAKkB,sBAAL,EAAhC,EAAP;AACA;AACD,WAAO,IAAP;AACA;;;8CAQ0B;AAC1B,SAAK5K,gBAAL,GAAwB,EAAxB;AACA;;;4BAgBQ;AACR,QAAI,KAAK0J,YAAL,EAAJ,EAAyB;AACxB,UAAKrB,KAAL;AACA;AACD;;;8CAQ0BpH,I,EAAM;AAChC,QAAIiG,WAAWxH,uBAAuByH,yBAAvB,EAAf;AACA,QAAIC,eAAeF,SAASG,WAAT,EAAnB;AACA,QAAI,CAACD,aAAaE,mBAAlB,EAAuC;AACtCF,kBAAaE,mBAAb,GAAmC,IAAnC;AACA,SAAIJ,SAASxF,OAAT,KAAqBT,IAAzB,EAA+B;AAC9BiG,eAASxF,OAAT,GAAmBT,IAAnB;AACA;AACD;AACD;;;kCAQctB,I,EAAM;AACpB,QAAIC,UAAUD,KAAKC,OAAnB;AACA,QAAImF,SAASrF,uBAAuByH,yBAAvB,EAAb;AACA,QAAI0D,eAAe9F,OAAO+F,eAAP,GAAyB/F,OAAO+F,eAAP,EAAzB,GAAoD,EAAvE;AACA,kBAAOC,KAAP,CAAanL,OAAb,EAAsBmF,OAAOnF,OAA7B,EAAsCiL,YAAtC;AACAlL,SAAKC,OAAL,GAAeA,OAAf;AACA;;;gDAjuBmC;AACnCoL,yBAAqBC,GAArB;AACA,QAAID,qBAAqBlK,MAArB,KAAgC,CAApC,EAAuC;AACtC,8CAA+BoK,aAA/B;AACA;AACD;;;+CAMkC;AAClC,WAAOF,qBAAqBA,qBAAqBlK,MAArB,GAA8B,CAAnD,CAAP;AACA;;;oCASuB;AACvB,QAAIY,UAAU8G,eAAe2C,cAAf,EAAd;AACA,QAAIxL,OAAOD,uBAAuByH,yBAAvB,EAAX;AACA,QAAIiD,WAAWzK,KAAK0H,WAAL,EAAf;AACA,QAAI+D,MAAMhB,QAAV;AACA,QAAIA,SAAS9C,mBAAT,IAAgC5F,YAAY/B,KAAK+B,OAAL,CAAaoD,UAA7D,EAAyE;AACxEsG,WAAM,aAAQzE,GAAR,CAAYjF,OAAZ,CAAN;AACA;AACD0J,QAAIxE,WAAJ,GAAkBwE,IAAIxE,WAAJ,IAAmB;AACpClC,gBAAW;AACVD,YAAM,EADI;AAEVI,aAAO;AAFG,MADyB;AAKpCL,gBAAW;AACVC,YAAM,EADI;AAEVI,aAAO;AAFG;AALyB,KAArC;AAUA,WAAOuG,IAAIxE,WAAX;AACA;;;gCAgWmB3F,I,EAAM;AACzB,WAAO,CAAC,CAACA,KAAK,iCAAuBoK,WAA5B,CAAT;AACA;;;0BAiGaC,Q,EAAUC,iB,EAAmBC,U,EAAY;AACtD,QAAI,CAAC,qBAAUC,eAAV,CAA0BH,QAA1B,CAAL,EAA0C;AACzC,SAAI1J,KAAK0J,QAAT;;AADyC,SAEnCI,aAFmC;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA,iCAG9B;AACT,YAAIhM,uBAAuByH,yBAAvB,EAAJ,EAAwD;AACvD,cAAKE,WAAL,GAAmB8C,cAAnB,CAAkC,IAAlC;AACA;AACD;AAPuC;AAAA;AAAA,gCAS/B;AACRvI,WAAG,KAAKyF,WAAL,GAAmBvH,OAAtB;AACA;AAXuC;;AAAA;AAAA;;AAazC4L,mBAAcC,QAAd,GAAyBjM,sBAAzB;AACA4L,gBAAWI,aAAX;AACA;AACD,WAAO,qBAAUrC,MAAV,CAAiBiC,QAAjB,EAA2BC,iBAA3B,EAA8CC,UAA9C,CAAP;AACA;;;+BAckB5I,K,EAAO;AACzBA,UAAM,iCAAuByI,WAA7B,EAA0CO,WAA1C,CAAsDhJ,KAAtD;AACA;;;6CAsKgCjD,I,EAAM;AACtCqL,yBAAqBhK,IAArB,CAA0BrB,IAA1B;AACA;;;;;;AA8CF,KAAIqL,uBAAuB,EAA3B;AACA,KAAI1I,iBAAiB,EAArB;;AAEA;AACA5C,wBAAuBuH,cAAvB,GAAwC,eAAxC;AACAvH,wBAAuB+G,cAAvB,GAAwC,eAAxC;;AAEA;AACA/G,wBAAuBuD,cAAvB,GAAwC,qCAAxC;;AAEA;AACA;AACA;AACAvD,wBAAuBmE,aAAvB,GAAuC,iBAAvC;;mBAEenE,sB","file":"node_modules/metal-incremental-dom/src/IncrementalDomRenderer.js","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport { core, object } from 'metal';\nimport dom from 'metal-dom';\nimport { domData } from 'metal-dom';\nimport { Component, ComponentRegistry, ComponentRenderer } from 'metal-component';\nimport IncrementalDomAop from './IncrementalDomAop';\nimport IncrementalDomChildren from './children/IncrementalDomChildren';\nimport IncrementalDomUnusedComponents from './cleanup/IncrementalDomUnusedComponents';\nimport IncrementalDomUtils from './utils/IncrementalDomUtils';\n\n/**\n * Class responsible for rendering components via incremental dom.\n */\nclass IncrementalDomRenderer extends ComponentRenderer {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor(comp) {\n\t\tsuper(comp);\n\n\t\tcomp.context = {};\n\t\tcomp.refs = {};\n\t\tthis.config_ = comp.getInitialConfig();\n\t\tthis.childComponents_ = [];\n\t\tthis.clearChanges_();\n\t\tcomp.on('attached', this.handleAttached_.bind(this));\n\n\t\t// Binds functions that will be used many times, to avoid creating new\n\t\t// functions each time.\n\t\tthis.handleInterceptedAttributesCall_ =\n\t\t\tthis.handleInterceptedAttributesCall_.bind(this);\n\t\tthis.handleInterceptedCloseCall_ =\n\t\t\tthis.handleInterceptedCloseCall_.bind(this);\n\t\tthis.handleInterceptedOpenCall_ =\n\t\t\tthis.handleInterceptedOpenCall_.bind(this);\n\t\tthis.handleChildrenCaptured_ = this.handleChildrenCaptured_.bind(this);\n\t\tthis.handleChildRender_ = this.handleChildRender_.bind(this);\n\t\tthis.renderInsidePatchDontSkip_ = this.renderInsidePatchDontSkip_.bind(this);\n\t}\n\n\t/**\n\t * Adds the given css classes to the specified arguments for an incremental\n\t * dom call, merging with the existing value if there is one.\n\t * @param {string} elementClasses\n\t * @param {!Array} args\n\t * @protected\n\t */\n\taddElementClasses_(elementClasses, args) {\n\t\tfor (var i = 3; i < args.length; i += 2) {\n\t\t\tif (args[i] === 'class') {\n\t\t\t\targs[i + 1] = this.removeDuplicateClasses_(\n\t\t\t\t\targs[i + 1] + ' ' + elementClasses\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\twhile (args.length < 3) {\n\t\t\targs.push(null);\n\t\t}\n\t\targs.push('class', elementClasses);\n\t}\n\n\t/**\n\t * Attaches inline listeners found on the first component render, since those\n\t * may come from existing elements on the page that already have\n\t * data-on[eventname] attributes set to its final value. This won't trigger\n\t * `handleInterceptedAttributesCall_`, so we need manual work to guarantee\n\t * that projects using progressive enhancement like this will still work.\n\t * @param {!Element} node\n\t * @param {!Array} args\n\t * @protected\n\t */\n\tattachDecoratedListeners_(node, args) {\n\t\tif (!this.component_.wasRendered) {\n\t\t\tvar attrs = (args[2] || []).concat(args.slice(3));\n\t\t\tfor (var i = 0; i < attrs.length; i += 2) {\n\t\t\t\tvar eventName = this.getEventFromListenerAttr_(attrs[i]);\n\t\t\t\tif (eventName && !node[eventName + '__handle__']) {\n\t\t\t\t\tthis.attachEvent_(node, attrs[i], eventName, attrs[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Listens to the specified event, attached via incremental dom calls.\n\t * @param {!Element} element\n\t * @param {string} key\n\t * @param {string} eventName\n\t * @param {function()|string} fn\n\t * @protected\n\t */\n\tattachEvent_(element, key, eventName, fn) {\n\t\tvar handleKey = eventName + '__handle__';\n\t\tif (element[handleKey]) {\n\t\t\telement[handleKey].removeListener();\n\t\t\telement[handleKey] = null;\n\t\t}\n\n\t\telement[key] = fn;\n\t\tif (fn) {\n\t\t\tif (core.isString(fn)) {\n\t\t\t\tif (key[0] === 'd') {\n\t\t\t\t\t// Allow data-on[eventkey] listeners to stay in the dom, as they\n\t\t\t\t\t// won't cause conflicts.\n\t\t\t\t\telement.setAttribute(key, fn);\n\t\t\t\t}\n\t\t\t\tfn = this.component_.getListenerFn(fn);\n\t\t\t}\n\t\t\telement[handleKey] = dom.delegate(document, eventName, element, fn);\n\t\t} else {\n\t\t\telement.removeAttribute(key);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the \"children\" array to be passed to the current component.\n\t * @param {!Array<!Object>} children\n\t * @return {!Array<!Object>}\n\t * @protected\n\t */\n\tbuildChildren_(children) {\n\t\treturn children.length === 0 ? emptyChildren_ : children;\n\t}\n\n\t/**\n\t * Returns an array with the args that should be passed to the component's\n\t * `shouldUpdate` method. This can be overridden by sub classes to change\n\t * what the method should receive.\n\t * @return {!Array}\n\t * @protected\n\t */\n\tbuildShouldUpdateArgs_() {\n\t\treturn [this.changes_];\n\t}\n\n\t/**\n\t * Clears the changes object.\n\t * @protected;\n\t */\n\tclearChanges_() {\n\t\tthis.changes_ = {};\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\n\t\tvar comp = this.component_;\n\t\tvar ref = this.config_.ref;\n\t\tvar owner = this.getOwner();\n\t\tif (owner && owner.components && owner.components[ref] === comp) {\n\t\t\tdelete owner.components[ref];\n\t\t}\n\n\t\tfor (var i = 0; i < this.childComponents_.length; i++) {\n\t\t\tconst child = this.childComponents_[i];\n\t\t\tif (!child.isDisposed()) {\n\t\t\t\tchild.element = null;\n\t\t\t\tchild.dispose();\n\t\t\t}\n\t\t}\n\t\tthis.childComponents_ = null;\n\t}\n\n\t/**\n\t * Removes the most recent component from the queue of rendering components.\n\t */\n\tstatic finishedRenderingComponent() {\n\t\trenderingComponents_.pop();\n\t\tif (renderingComponents_.length === 0) {\n\t\t\tIncrementalDomUnusedComponents.disposeUnused();\n\t\t}\n\t}\n\n\t/**\n\t * Gets the component being currently rendered via `IncrementalDomRenderer`.\n\t * @return {Component}\n\t */\n\tstatic getComponentBeingRendered() {\n\t\treturn renderingComponents_[renderingComponents_.length - 1];\n\t}\n\n\t/**\n\t * Gets the data object that should be currently used. This object will either\n\t * come from the current element being rendered by incremental dom or from\n\t * the component instance being rendered (only when the current element is the\n\t * component's direct parent).\n\t * @return {!Object}\n\t */\n\tstatic getCurrentData() {\n\t\tvar element = IncrementalDOM.currentElement();\n\t\tvar comp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar renderer = comp.getRenderer();\n\t\tvar obj = renderer;\n\t\tif (renderer.rootElementReached_ && element !== comp.element.parentNode) {\n\t\t\tobj = domData.get(element);\n\t\t}\n\t\tobj.incDomData_ = obj.incDomData_ || {\n\t\t\tcurrComps: {\n\t\t\t\tkeys: {},\n\t\t\t\torder: {}\n\t\t\t},\n\t\t\tprevComps: {\n\t\t\t\tkeys: {},\n\t\t\t\torder: {}\n\t\t\t}\n\t\t};\n\t\treturn obj.incDomData_;\n\t}\n\n\t/**\n\t * Returns the event name if the given attribute is a listener (of the form\n\t * \"on<EventName>\"), or null if it isn't.\n\t * @param {string} attr\n\t * @return {?string}\n\t * @protected\n\t */\n\tgetEventFromListenerAttr_(attr) {\n\t\tvar matches = IncrementalDomRenderer.LISTENER_REGEX.exec(attr);\n\t\tvar eventName = matches ? (matches[1] ? matches[1] : matches[2]) : null;\n\t\treturn eventName ? eventName.toLowerCase() : null;\n\t}\n\n\t/**\n\t * Gets the component that is this component's owner (that is, the one that\n\t * passed its data and holds its ref), or null if there's none.\n\t * @return {Component}\n\t */\n\tgetOwner() {\n\t\treturn this.owner_;\n\t}\n\n\t/**\n\t * Gets the component that is this component's parent (that is, the one that\n\t * actually rendered it), or null if there's no parent.\n\t * @return {Component}\n\t */\n\tgetParent() {\n\t\treturn this.parent_;\n\t}\n\n\t/**\n\t * Returns the \"ref\" to be used for a component. Uses \"key\" as \"ref\" when\n\t * compatibility mode is on for the current renderer.\n\t * @param {!Object} config\n\t * @param {?string} ref\n\t * @protected\n\t */\n\tgetRef_(config) {\n\t\tconst compatData = core.getCompatibilityModeData();\n\t\tif (compatData) {\n\t\t\tconst renderers = compatData.renderers;\n\t\t\tconst useKey = !renderers ||\n\t\t\t\trenderers.indexOf(this.constructor) !== -1 ||\n\t\t\t\trenderers.indexOf(this.constructor.RENDERER_NAME) !== -1;\n\t\t\tif (useKey && config.key && !config.ref) {\n\t\t\t\treturn config.key;\n\t\t\t}\n\t\t}\n\t\treturn config.ref;\n\t}\n\n\t/**\n\t * Gets the sub component referenced by the given tag and config data,\n\t * creating it if it doesn't yet exist.\n\t * @param {string|!Function} tagOrCtor The tag name.\n\t * @param {!Object} config The config object for the sub component.\n\t * @param {Component=} opt_owner\n\t * @return {!Component} The sub component.\n\t * @protected\n\t */\n\tgetSubComponent_(tagOrCtor, config, opt_owner) {\n\t\tvar Ctor = tagOrCtor;\n\t\tif (core.isString(Ctor)) {\n\t\t\tCtor = ComponentRegistry.getConstructor(tagOrCtor);\n\t\t}\n\n\t\tconst ref = this.getRef_(config);\n\t\tvar data = IncrementalDomRenderer.getCurrentData();\n\t\tvar comp;\n\t\tif (core.isDef(ref)) {\n\t\t\tconst owner = opt_owner || this.component_;\n\t\t\tcomp = this.match_(owner.components[ref], Ctor, config);\n\t\t\towner.addSubComponent(ref, comp);\n\t\t\towner.refs[ref] = comp;\n\t\t} else if (core.isDef(config.key)) {\n\t\t\tcomp = this.match_(data.prevComps.keys[config.key], Ctor, config);\n\t\t\tdata.currComps.keys[config.key] = comp;\n\t\t} else {\n\t\t\tvar type = core.getUid(Ctor, true);\n\t\t\tdata.currComps.order[type] = data.currComps.order[type] || [];\n\t\t\tvar order = data.currComps.order[type];\n\t\t\tcomp = this.match_((data.prevComps.order[type] || [])[order.length], Ctor, config);\n\t\t\torder.push(comp);\n\t\t}\n\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Guarantees that the component's element has a parent. That's necessary\n\t * when calling incremental dom's `patchOuter` for now, as otherwise it will\n\t * throw an error if the element needs to be replaced.\n\t * @return {Element} The parent, in case it was added.\n\t * @protected\n\t */\n\tguaranteeParent_() {\n\t\tvar element = this.component_.element;\n\t\tif (!element || !element.parentNode) {\n\t\t\tvar parent = document.createElement('div');\n\t\t\tif (element) {\n\t\t\t\tdom.append(parent, element);\n\t\t\t}\n\t\t\treturn parent;\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `attached` listener. Stores attach data.\n\t * @param {!Object} data\n\t * @protected\n\t */\n\thandleAttached_(data) {\n\t\tthis.attachData_ = data;\n\t}\n\n\t/**\n\t * Handles the event of children having finished being captured.\n\t * @param {!Object} The captured children in tree format.\n\t * @protected\n\t */\n\thandleChildrenCaptured_(tree) {\n\t\tvar {props, tag} = this.componentToRender_;\n\t\tprops.children = this.buildChildren_(tree.props.children);\n\t\tthis.componentToRender_ = null;\n\t\tthis.renderFromTag_(tag, props);\n\t}\n\n\t/**\n\t * Handles a child being rendered via `IncrementalDomChildren.render`. Skips\n\t * component nodes so that they can be rendered the correct way without\n\t * having to recapture both them and their children via incremental dom.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t * @protected\n\t */\n\thandleChildRender_(node) {\n\t\tif (node.tag && IncrementalDomUtils.isComponentTag(node.tag)) {\n\t\t\tnode.props.children = this.buildChildren_(node.props.children);\n\t\t\tconst owner = IncrementalDomChildren.getOwner(node);\n\t\t\tthis.renderFromTag_(\n\t\t\t\tnode.tag,\n\t\t\t\tnode.props,\n\t\t\t\towner && owner.getComponent()\n\t\t\t);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\thandleDataManagerCreated_() {\n\t\tsuper.handleDataManagerCreated_();\n\n\t\tvar manager = this.component_.getDataManager();\n\t\tif (!this.component_.constructor.SYNC_UPDATES_MERGED) {\n\t\t\t// If the component is being updated synchronously we'll just reuse the\n\t\t\t// `handleComponentRendererStateKeyChanged_` function from\n\t\t\t// `ComponentRenderer`.\n\t\t\tmanager.on('dataPropChanged', this.handleDataPropChanged_.bind(this));\n\t\t}\n\n\t\tmanager.add(\n\t\t\t'children',\n\t\t\t{\n\t\t\t\tvalidator: Array.isArray,\n\t\t\t\tvalue: emptyChildren_\n\t\t\t},\n\t\t\tthis.config_.children || emptyChildren_\n\t\t);\n\t}\n\n\t/**\n\t * Handles the `dataPropChanged` event. Stores data that has changed since the\n\t * last render.\n\t * @param {!Object} data\n\t * @protected\n\t */\n\thandleDataPropChanged_(data) {\n\t\tthis.changes_[data.key] = data;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the attributes default handler from\n\t * incremental dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {!Element} element\n\t * @param {string} name\n\t * @param {*} value\n\t * @protected\n\t */\n\thandleInterceptedAttributesCall_(originalFn, element, name, value) {\n\t\tvar eventName = this.getEventFromListenerAttr_(name);\n\t\tif (eventName) {\n\t\t\tthis.attachEvent_(element, name, eventName, value);\n\t\t\treturn;\n\t\t}\n\n\t\tif (name === 'checked') {\n\t\t\t// This is a temporary fix to account for incremental dom setting\n\t\t\t// \"checked\" as an attribute only, which can cause bugs since that won't\n\t\t\t// necessarily check/uncheck the element it's set on. See\n\t\t\t// https://github.com/google/incremental-dom/issues/198 for more details.\n\t\t\tvalue = core.isDefAndNotNull(value) && value !== false;\n\t\t}\n\n\t\tif (name === 'value' && element.value !== value) {\n\t\t\t// This is a temporary fix to account for incremental dom setting\n\t\t\t// \"value\" as an attribute only, which can cause bugs since that won't\n\t\t\t// necessarily update the input's content it's set on. See\n\t\t\t// https://github.com/google/incremental-dom/issues/239 for more details.\n\t\t\t// We only do this if the new value is different though, as otherwise the\n\t\t\t// browser will automatically move the typing cursor to the end of the\n\t\t\t// field.\n\t\t\telement[name] = value;\n\t\t}\n\n\t\tif (core.isBoolean(value)) {\n\t\t\t// Incremental dom sets boolean values as string data attributes, which\n\t\t\t// is counter intuitive. This changes the behavior to use the actual\n\t\t\t// boolean value.\n\t\t\telement[name] = value;\n\t\t\tif (value) {\n\t\t\t\telement.setAttribute(name, '');\n\t\t\t} else {\n\t\t\t\telement.removeAttribute(name);\n\t\t\t}\n\t\t} else {\n\t\t\toriginalFn(element, name, value);\n\t\t}\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementClose` function from incremental\n\t * dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @protected\n\t */\n\thandleInterceptedCloseCall_(originalFn, tag) {\n\t\tthis.emit(IncrementalDomRenderer.ELEMENT_CLOSED, {tag});\n\t\tvar element = originalFn(tag);\n\t\tthis.resetData_(domData.get(element).incDomData_);\n\t\treturn element;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @protected\n\t */\n\thandleInterceptedOpenCall_(originalFn, tag) {\n\t\tif (IncrementalDomUtils.isComponentTag(tag)) {\n\t\t\treturn this.handleSubComponentCall_.apply(this, arguments);\n\t\t} else {\n\t\t\treturn this.handleRegularCall_.apply(this, arguments);\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `dataPropChanged` event. Overrides original method from\n\t * `ComponentRenderer` to guarantee that `IncrementalDomRenderer`'s logic\n\t * will run first.\n\t * @param {!Object} data\n\t * @override\n\t * @protected\n\t */\n\thandleManagerDataPropChanged_(data) {\n\t\tthis.handleDataPropChanged_(data);\n\t\tsuper.handleManagerDataPropChanged_(data);\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a regular element. Adds any inline listeners found on the\n\t * first render and makes sure that component root elements are always reused.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @protected\n\t */\n\thandleRegularCall_(originalFn, ...args) {\n\t\tthis.emit(IncrementalDomRenderer.ELEMENT_OPENED, {args});\n\t\tvar currComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar currRenderer = currComp.getRenderer();\n\t\tif (!currRenderer.rootElementReached_) {\n\t\t\tif (currRenderer.config_.key) {\n\t\t\t\targs[1] = currRenderer.config_.key;\n\t\t\t}\n\t\t\tvar elementClasses = currComp.getDataManager().get('elementClasses');\n\t\t\tif (elementClasses) {\n\t\t\t\tthis.addElementClasses_(elementClasses, args);\n\t\t\t}\n\t\t}\n\n\n\t\tvar node = originalFn.apply(null, args);\n\t\tthis.attachDecoratedListeners_(node, args);\n\t\tthis.updateElementIfNotReached_(node);\n\n\t\tconst config = IncrementalDomUtils.buildConfigFromCall(args);\n\t\tif (core.isDefAndNotNull(config.ref)) {\n\t\t\tthis.component_.refs[config.ref] = node;\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a sub component element. Creates and updates the appropriate\n\t * sub component.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @protected\n\t */\n\thandleSubComponentCall_(originalFn, ...args) {\n\t\tvar props = IncrementalDomUtils.buildConfigFromCall(args);\n\t\tthis.componentToRender_ = {\n\t\t\tprops,\n\t\t\ttag: args[0]\n\t\t};\n\t\tIncrementalDomChildren.capture(this, this.handleChildrenCaptured_);\n\t}\n\n\t/**\n\t * Checks if the component's data has changed.\n\t * @return {boolean}\n\t * @protected\n\t */\n\thasDataChanged_() {\n\t\treturn Object.keys(this.changes_).length > 0;\n\t}\n\n\t/**\n\t * Intercepts incremental dom calls from this component.\n\t * @protected\n\t */\n\tintercept_() {\n\t\tIncrementalDomAop.startInterception({\n\t\t\tattributes: this.handleInterceptedAttributesCall_,\n\t\t\telementClose: this.handleInterceptedCloseCall_,\n\t\t\telementOpen: this.handleInterceptedOpenCall_\n\t\t});\n\t}\n\n\t/**\n\t * Checks if the given object is an incremental dom node.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t */\n\tstatic isIncDomNode(node) {\n\t\treturn !!node[IncrementalDomChildren.CHILD_OWNER];\n\t}\n\n\t/**\n\t * Checks if the given component can be a match for a constructor.\n\t * @param {!Component} comp\n\t * @param {!function()} Ctor\n\t * @return {boolean}\n\t * @protected\n\t */\n\tisMatch_(comp, Ctor) {\n\t\tif (!comp || comp.constructor !== Ctor || comp.isDisposed()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn comp.getRenderer().getOwner() === this.component_;\n\t}\n\n\t/**\n\t * Returns the given component if it matches the specified constructor\n\t * function. Otherwise, returns a new instance of the given constructor. On\n\t * both cases the component's state and config will be updated.\n\t * @param {Component} comp\n\t * @param {!function()} Ctor\n\t * @param {!Object} config\n\t * @return {!Component}\n\t * @protected\n\t */\n\tmatch_(comp, Ctor, config) {\n\t\tif (!this.isMatch_(comp, Ctor)) {\n\t\t\tcomp = new Ctor(config, false);\n\t\t}\n\t\tif (comp.wasRendered) {\n\t\t\tcomp.getRenderer().startSkipUpdates();\n\t\t\tcomp.getDataManager().replaceNonInternal(config);\n\t\t\tcomp.getRenderer().stopSkipUpdates();\n\t\t}\n\t\tcomp.getRenderer().config_ = config;\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Patches the component's element with the incremental dom function calls\n\t * done by `renderInsidePatchDontSkip_`.\n\t */\n\tpatch() {\n\t\tif (!this.component_.element && this.parent_) {\n\t\t\t// If the component has no content but was rendered from another component,\n\t\t\t// we'll need to patch this parent to make sure that any new content will\n\t\t\t// be added in the right place.\n\t\t\tthis.parent_.getRenderer().patch();\n\t\t\treturn;\n\t\t}\n\n\t\tvar tempParent = this.guaranteeParent_();\n\t\tif (tempParent) {\n\t\t\tIncrementalDOM.patch(tempParent, this.renderInsidePatchDontSkip_);\n\t\t\tdom.exitDocument(this.component_.element);\n\t\t\tif (this.component_.element && this.component_.inDocument) {\n\t\t\t\tthis.component_.renderElement_(\n\t\t\t\t\tthis.attachData_.parent,\n\t\t\t\t\tthis.attachData_.sibling\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst element = this.component_.element;\n\t\t\tIncrementalDOM.patchOuter(element, this.renderInsidePatchDontSkip_);\n\t\t}\n\t}\n\n\t/**\n\t * Removes duplicate css classes from the given string.\n\t * @param {string} cssClasses\n\t * @return {string}\n\t * @protected\n\t */\n\tremoveDuplicateClasses_(cssClasses) {\n\t\tvar noDuplicates = [];\n\t\tvar all = cssClasses.split(/\\s+/);\n\t\tvar used = {};\n\t\tfor (var i = 0; i < all.length; i++) {\n\t\t\tif (!used[all[i]]) {\n\t\t\t\tused[all[i]] = true;\n\t\t\t\tnoDuplicates.push(all[i]);\n\t\t\t}\n\t\t}\n\t\treturn noDuplicates.join(' ');\n\t}\n\n\t/**\n\t * Creates and renders the given function, which can either be a simple\n\t * incremental dom function or a component constructor.\n\t * @param {!function()} fnOrCtor Either be a simple incremental dom function\n\t or a component constructor.\n\t * @param {Object|Element=} opt_dataOrElement Optional config data for the\n\t *     function or parent for the rendered content.\n\t * @param {Element=} opt_parent Optional parent for the rendered content.\n\t * @return {!Component} The rendered component's instance.\n\t */\n\tstatic render(fnOrCtor, opt_dataOrElement, opt_parent) {\n\t\tif (!Component.isComponentCtor(fnOrCtor)) {\n\t\t\tvar fn = fnOrCtor;\n\t\t\tclass TempComponent extends Component {\n\t\t\t\tcreated() {\n\t\t\t\t\tif (IncrementalDomRenderer.getComponentBeingRendered()) {\n\t\t\t\t\t\tthis.getRenderer().updateContext_(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trender() {\n\t\t\t\t\tfn(this.getRenderer().config_);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTempComponent.RENDERER = IncrementalDomRenderer;\n\t\t\tfnOrCtor = TempComponent;\n\t\t}\n\t\treturn Component.render(fnOrCtor, opt_dataOrElement, opt_parent);\n\t}\n\n\t/**\n\t * Renders the renderer's component for the first time, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`.\n\t */\n\trender() {\n\t\tthis.patch();\n\t}\n\n\t/**\n\t * Renders the given child node via its owner renderer.\n\t * @param {!Object} child\n\t */\n\tstatic renderChild(child) {\n\t\tchild[IncrementalDomChildren.CHILD_OWNER].renderChild(child);\n\t}\n\n\t/**\n\t * Renders the given child node.\n\t * @param {!Object} child\n\t */\n\trenderChild(child) {\n\t\tthis.intercept_();\n\t\tIncrementalDomChildren.render(child, this.handleChildRender_);\n\t\tIncrementalDomAop.stopInterception();\n\t}\n\n\t/**\n\t * Renders the contents for the given tag.\n\t * @param {!function()|string} tag\n\t * @param {!Object} config\n\t * @param {Component=} opt_owner\n\t * @protected\n\t */\n\trenderFromTag_(tag, config, opt_owner) {\n\t\tif (core.isString(tag) || tag.prototype.getRenderer) {\n\t\t\tvar comp = this.renderSubComponent_(tag, config, opt_owner);\n\t\t\tthis.updateElementIfNotReached_(comp.element);\n\t\t\treturn comp.element;\n\t\t} else {\n\t\t\treturn tag(config);\n\t\t}\n\t}\n\n\t/**\n\t * Calls functions from `IncrementalDOM` to build the component element's\n\t * content. Can be overriden by subclasses (for integration with template\n\t * engines for example).\n\t */\n\trenderIncDom() {\n\t\tif (this.component_.render) {\n\t\t\tthis.component_.render();\n\t\t} else {\n\t\t\tIncrementalDOM.elementVoid('div');\n\t\t}\n\t}\n\n\t/**\n\t * Runs the incremental dom functions for rendering this component, but\n\t * doesn't call `patch` yet. Rather, this will be the function that should be\n\t * called by `patch`.\n\t */\n\trenderInsidePatch() {\n\t\tif (this.component_.wasRendered &&\n\t\t\t!this.shouldUpdate() &&\n\t\t\tIncrementalDOM.currentPointer() === this.component_.element) {\n\t\t\tif (this.component_.element) {\n\t\t\t\tIncrementalDOM.skipNode();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.renderInsidePatchDontSkip_();\n\t}\n\n\t/**\n\t * The same as `renderInsidePatch`, but without the check that may skip the\n\t * render action.\n\t * @protected\n\t */\n\trenderInsidePatchDontSkip_() {\n\t\tIncrementalDomRenderer.startedRenderingComponent(this.component_);\n\t\tthis.clearChanges_();\n\t\tthis.rootElementReached_ = false;\n\t\tIncrementalDomUnusedComponents.schedule(this.childComponents_);\n\t\tthis.childComponents_ = [];\n\t\tthis.component_.refs = {};\n\t\tthis.intercept_();\n\t\tthis.renderIncDom();\n\t\tIncrementalDomAop.stopInterception();\n\t\tif (!this.rootElementReached_) {\n\t\t\tthis.component_.element = null;\n\t\t}\n\t\tthis.emit('rendered', !this.isRendered_);\n\t\tIncrementalDomRenderer.finishedRenderingComponent();\n\t\tthis.resetData_(this.incDomData_);\n\t}\n\n\t/**\n\t * This updates the sub component that is represented by the given data.\n\t * The sub component is created, added to its parent and rendered. If it\n\t * had already been rendered before though, it will only have its state\n\t * updated instead.\n\t * @param {string|!function()} tagOrCtor The tag name or constructor function.\n\t * @param {!Object} config The config object for the sub component.\n\t * @param {Component=} opt_owner\n\t * @return {!Component} The updated sub component.\n\t * @protected\n\t */\n\trenderSubComponent_(tagOrCtor, config, opt_owner) {\n\t\tvar comp = this.getSubComponent_(tagOrCtor, config, opt_owner);\n\t\tthis.updateContext_(comp);\n\t\tvar renderer = comp.getRenderer();\n\t\tif (renderer instanceof IncrementalDomRenderer) {\n\t\t\tconst parentComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\t\tconst parentRenderer = parentComp.getRenderer();\n\t\t\tparentRenderer.childComponents_.push(comp);\n\t\t\trenderer.parent_ = parentComp;\n\t\t\trenderer.owner_ = opt_owner || this.component_;\n\t\t\tif (!config.key && !parentRenderer.rootElementReached_) {\n\t\t\t\tconfig.key = parentRenderer.config_.key;\n\t\t\t}\n\t\t\trenderer.renderInsidePatch();\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t'IncrementalDomRenderer doesn\\'t support rendering sub components ' +\n\t\t\t\t'that don\\'t use IncrementalDomRenderer as well, like:',\n\t\t\t\tcomp\n\t\t\t);\n\t\t}\n\t\tif (!comp.wasRendered) {\n\t\t\tcomp.renderAsSubComponent();\n\t\t}\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Resets the given incremental dom data object, preparing it for the next\n\t * pass.\n\t * @param {Object} data\n\t * @protected\n\t */\n\tresetData_(data) {\n\t\tif (data) {\n\t\t\tdata.prevComps.keys = data.currComps.keys;\n\t\t\tdata.prevComps.order = data.currComps.order;\n\t\t\tdata.currComps.keys = {};\n\t\t\tdata.currComps.order = {};\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the component should be updated with the current state changes.\n\t * Can be overridden by subclasses or implemented by components to provide\n\t * customized behavior (only updating when a state property used by the\n\t * template changes, for example).\n\t * @return {boolean}\n\t */\n\tshouldUpdate() {\n\t\tif (!this.hasDataChanged_()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.component_.shouldUpdate) {\n\t\t\treturn this.component_.shouldUpdate(...this.buildShouldUpdateArgs_());\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Skips the next disposal of children components, by clearing the array as\n\t * if there were no children rendered the last time. This can be useful for\n\t * allowing components to be reused by other parent components in separate\n\t * render update cycles.\n\t */\n\tskipNextChildrenDisposal() {\n\t\tthis.childComponents_ = [];\n\t}\n\n\t/**\n\t * Stores the component that has just started being rendered.\n\t * @param {!Component} comp\n\t */\n\tstatic startedRenderingComponent(comp) {\n\t\trenderingComponents_.push(comp);\n\t}\n\n\t/**\n\t * Updates the renderer's component when state changes, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`. Makes\n\t * sure that it won't cause a rerender if the only change was for the\n\t * \"element\" property.\n\t */\n\tupdate() {\n\t\tif (this.shouldUpdate()) {\n\t\t\tthis.patch();\n\t\t}\n\t}\n\n\t/**\n\t * Updates this renderer's component's element with the given values, unless\n\t * it has already been reached by an earlier call.\n\t * @param {!Element} node\n\t * @protected\n\t */\n\tupdateElementIfNotReached_(node) {\n\t\tvar currComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar currRenderer = currComp.getRenderer();\n\t\tif (!currRenderer.rootElementReached_) {\n\t\t\tcurrRenderer.rootElementReached_ = true;\n\t\t\tif (currComp.element !== node) {\n\t\t\t\tcurrComp.element = node;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates the given component's context according to the data from the\n\t * component that is currently being rendered.\n\t * @param {!Component} comp\n\t * @protected\n\t */\n\tupdateContext_(comp) {\n\t\tvar context = comp.context;\n\t\tvar parent = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar childContext = parent.getChildContext ? parent.getChildContext() : {};\n\t\tobject.mixin(context, parent.context, childContext);\n\t\tcomp.context = context;\n\t}\n}\n\nvar renderingComponents_ = [];\nvar emptyChildren_ = [];\n\n// Constants used as event names.\nIncrementalDomRenderer.ELEMENT_OPENED = 'elementOpened';\nIncrementalDomRenderer.ELEMENT_CLOSED = 'elementClosed';\n\n// Regex pattern used to find inline listeners.\nIncrementalDomRenderer.LISTENER_REGEX = /^(?:on([A-Z]\\w+))|(?:data-on(\\w+))$/;\n\n// Name of this renderer. Renderers should provide this as a way to identify\n// them via a simple string (when calling core.enableCompatibilityMode to\n// add support to old features for specific renderers for example).\nIncrementalDomRenderer.RENDERER_NAME = 'incremental-dom';\n\nexport default IncrementalDomRenderer;\n"],"sourceRoot":"/source/"}