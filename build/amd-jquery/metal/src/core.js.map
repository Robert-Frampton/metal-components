{"version":3,"sources":["core.js"],"names":["compatibilityModeData_","core","Error","constructor","propertyName","propertyValues","__proto__","isPrototypeOf","Function","push","opt_data","window","__METAL_COMPATIBILITY__","enableCompatibilityMode","fn","name","str","toString","substring","indexOf","opt_object","opt_noInheritance","id","UID_PROPERTY","hasOwnProperty","uniqueIdCounter_","opt_returnValue","val","undefined","isDef","isNull","nodeType","type","then","String","opt_mergeFn","mergedName","merged","collectSuperClassesProperty","Math","random"],"mappings":"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","file":"node_modules/metal/src/core.js","sourcesContent":["'use strict';\n\nlet compatibilityModeData_;\n\n/**\n * A collection of core utility functions.\n * @const\n */\nclass core {\n\t/**\n\t * When defining a class Foo with an abstract method bar(), you can do:\n\t * Foo.prototype.bar = core.abstractMethod\n\t *\n\t * Now if a subclass of Foo fails to override bar(), an error will be thrown\n\t * when bar() is invoked.\n\t *\n\t * @type {!Function}\n\t * @throws {Error} when invoked to indicate the method should be overridden.\n\t */\n\tstatic abstractMethod() {\n\t\tthrow Error('Unimplemented abstract method');\n\t}\n\n\t/**\n\t * Loops constructor super classes collecting its properties values. If\n\t * property is not available on the super class `undefined` will be\n\t * collected as value for the class hierarchy position.\n\t * @param {!function()} constructor Class constructor.\n\t * @param {string} propertyName Property name to be collected.\n\t * @return {Array.<*>} Array of collected values.\n\t * TODO(*): Rethink superclass loop.\n\t */\n\tstatic collectSuperClassesProperty(constructor, propertyName) {\n\t\tvar propertyValues = [constructor[propertyName]];\n\t\twhile (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {\n\t\t\tconstructor = constructor.__proto__;\n\t\t\tpropertyValues.push(constructor[propertyName]);\n\t\t}\n\t\treturn propertyValues;\n\t}\n\n\t/**\n\t * Disables Metal.js's compatibility mode.\n\t */\n\tstatic disableCompatibilityMode() {\n\t\tcompatibilityModeData_ = null;\n\t}\n\n\t/**\n\t * Enables Metal.js's compatibility mode with the following features from rc\n\t * and 1.x versions:\n\t *     - Using \"key\" to reference component instances. In the current version\n\t *       this should be done via \"ref\" instead. This allows old code still\n\t *       using \"key\" to keep working like before. NOTE: this may cause\n\t *       problems, since \"key\" is meant to be used differently. Only use this\n\t *       if it's not possible to upgrade the code to use \"ref\" instead.\n\t * @param {Object=} opt_data Optional object with data to specify more\n\t *     details, such as:\n\t *         - renderers {Array} the template renderers that should be in\n\t *           compatibility mode, either their constructors or strings\n\t *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones\n\t *           that extend from IncrementalDomRenderer.\n\t * @type {Object}\n\t */\n\tstatic enableCompatibilityMode(opt_data = {}) {\n\t\tcompatibilityModeData_ = opt_data;\n\t}\n\n\t/**\n\t * Returns the data used for compatibility mode, or nothing if it hasn't been\n\t * enabled.\n\t * @return {Object}\n\t */\n\tstatic getCompatibilityModeData() {\n\t\t// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.\n\t\tif (!compatibilityModeData_) {\n\t\t\tif (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {\n\t\t\t\tcore.enableCompatibilityMode(window.__METAL_COMPATIBILITY__);\n\t\t\t}\n\t\t}\n\t\treturn compatibilityModeData_;\n\t}\n\n\t/**\n\t * Gets the name of the given function. If the current browser doesn't\n\t * support the `name` property, this will calculate it from the function's\n\t * content string.\n\t * @param {!function()} fn\n\t * @return {string}\n\t */\n\tstatic getFunctionName(fn) {\n\t\tif (!fn.name) {\n\t\t\tvar str = fn.toString();\n\t\t\tfn.name = str.substring(9, str.indexOf('('));\n\t\t}\n\t\treturn fn.name;\n\t}\n\n\t/**\n\t * Gets an unique id. If `opt_object` argument is passed, the object is\n\t * mutated with an unique id. Consecutive calls with the same object\n\t * reference won't mutate the object again, instead the current object uid\n\t * returns. See {@link core.UID_PROPERTY}.\n\t * @param {Object=} opt_object Optional object to be mutated with the uid. If\n\t *     not specified this method only returns the uid.\n\t * @param {boolean=} opt_noInheritance Optional flag indicating if this\n\t *     object's uid property can be inherited from parents or not.\n\t * @throws {Error} when invoked to indicate the method should be overridden.\n\t */\n\tstatic getUid(opt_object, opt_noInheritance) {\n\t\tif (opt_object) {\n\t\t\tvar id = opt_object[core.UID_PROPERTY];\n\t\t\tif (opt_noInheritance && !opt_object.hasOwnProperty(core.UID_PROPERTY)) {\n\t\t\t\tid = null;\n\t\t\t}\n\t\t\treturn id || (opt_object[core.UID_PROPERTY] = core.uniqueIdCounter_++);\n\t\t}\n\t\treturn core.uniqueIdCounter_++;\n\t}\n\n\t/**\n\t * The identity function. Returns its first argument.\n\t * @param {*=} opt_returnValue The single value that will be returned.\n\t * @return {?} The first argument.\n\t */\n\tstatic identityFunction(opt_returnValue) {\n\t\treturn opt_returnValue;\n\t}\n\n\t/**\n\t * Returns true if the specified value is a boolean.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is boolean.\n\t */\n\tstatic isBoolean(val) {\n\t\treturn typeof val === 'boolean';\n\t}\n\n\t/**\n\t * Returns true if the specified value is not undefined.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is defined.\n\t */\n\tstatic isDef(val) {\n\t\treturn val !== undefined;\n\t}\n\n\t/**\n\t * Returns true if value is not undefined or null.\n\t * @param {*} val\n\t * @return {boolean}\n\t */\n\tstatic isDefAndNotNull(val) {\n\t\treturn core.isDef(val) && !core.isNull(val);\n\t}\n\n\t/**\n\t * Returns true if value is a document.\n\t * @param {*} val\n\t * @return {boolean}\n\t */\n\tstatic isDocument(val) {\n\t\treturn val && typeof val === 'object' && val.nodeType === 9;\n\t}\n\n\t/**\n\t * Returns true if value is a dom element.\n\t * @param {*} val\n\t * @return {boolean}\n\t */\n\tstatic isElement(val) {\n\t\treturn val && typeof val === 'object' && val.nodeType === 1;\n\t}\n\n\t/**\n\t * Returns true if the specified value is a function.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is a function.\n\t */\n\tstatic isFunction(val) {\n\t\treturn typeof val === 'function';\n\t}\n\n\t/**\n\t * Returns true if value is null.\n\t * @param {*} val\n\t * @return {boolean}\n\t */\n\tstatic isNull(val) {\n\t\treturn val === null;\n\t}\n\n\t/**\n\t * Returns true if the specified value is a number.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is a number.\n\t */\n\tstatic isNumber(val) {\n\t\treturn typeof val === 'number';\n\t}\n\n\t/**\n\t * Returns true if value is a window.\n\t * @param {*} val\n\t * @return {boolean}\n\t */\n\tstatic isWindow(val) {\n\t\treturn val !== null && val === val.window;\n\t}\n\n\t/**\n\t * Returns true if the specified value is an object. This includes arrays\n\t * and functions.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is an object.\n\t */\n\tstatic isObject(val) {\n\t\tvar type = typeof val;\n\t\treturn type === 'object' && val !== null || type === 'function';\n\t}\n\n\t/**\n\t * Returns true if value is a Promise.\n\t * @param {*} val\n\t * @return {boolean}\n\t */\n\tstatic isPromise(val) {\n\t\treturn val && typeof val === 'object' && typeof val.then === 'function';\n\t}\n\n\t/**\n\t * Returns true if value is a string.\n\t * @param {*} val\n\t * @return {boolean}\n\t */\n\tstatic isString(val) {\n\t\treturn typeof val === 'string' || val instanceof String;\n\t}\n\n\t/**\n\t * Merges the values of a static property a class with the values of that\n\t * property for all its super classes, and stores it as a new static\n\t * property of that class. If the static property already existed, it won't\n\t * be recalculated.\n\t * @param {!function()} constructor Class constructor.\n\t * @param {string} propertyName Property name to be collected.\n\t * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled\n\t *   with the values of the property for the current class and all its super classes.\n\t *   Should return the merged value to be stored on the current class.\n\t * @return {boolean} Returns true if merge happens, false otherwise.\n\t */\n\tstatic mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {\n\t\tvar mergedName = propertyName + '_MERGED';\n\t\tif (constructor.hasOwnProperty(mergedName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar merged = core.collectSuperClassesProperty(constructor, propertyName);\n\t\tif (opt_mergeFn) {\n\t\t\tmerged = opt_mergeFn(merged);\n\t\t}\n\t\tconstructor[mergedName] = merged;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Null function used for default values of callbacks, etc.\n\t * @return {void} Nothing.\n\t */\n\tstatic nullFunction() {}\n}\n\n/**\n * Unique id property prefix.\n * @type {String}\n * @protected\n */\ncore.UID_PROPERTY = 'core_' + ((Math.random() * 1e9) >>> 0);\n\n/**\n * Counter for unique id.\n * @type {Number}\n * @private\n */\ncore.uniqueIdCounter_ = 1;\n\nexport default core;\n"],"sourceRoot":"/source/"}