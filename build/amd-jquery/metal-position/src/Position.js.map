{"version":3,"sources":["Position.js"],"names":["Position","node","getClientSize_","prop","el","isWindow","document","documentElement","isDocument","opt_element","height","getHeight","width","getWidth","makeRegion","getSize_","opt_ignoreTransform","offsetLeft","getTranslation","left","offsetTop","top","opt_includeScroll","getDocumentRegion_","makeRegionFromBoundingRect_","getBoundingClientRect","pageXOffset","defaultView","scrollLeft","pageYOffset","scrollTop","docEl","Math","max","body","style","getComputedStyle","transform","msTransform","webkitTransform","mozTransform","values","regex","matches","exec","push","getTransformMatrixValues","translation","parseFloat","length","r1","r2","intersectRect","bottom","right","region","insideRegion","getRegion","window","intersectRegion","min","rect","deltaX","getScrollLeft","deltaY","getScrollTop","x","y"],"mappings":"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","file":"node_modules/metal-position/src/Position.js","sourcesContent":["'use strict';\n\nimport core from 'metal';\nimport Geometry from './Geometry';\n\n/**\n * Class with static methods responsible for doing browser position checks.\n */\nclass Position {\n\t/**\n\t * Gets the client height of the specified node. Scroll height is not\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getClientHeight(node) {\n\t\treturn this.getClientSize_(node, 'Height');\n\t}\n\n\t/**\n\t * Gets the client height or width of the specified node. Scroll height is\n\t * not included.\n\t * @param {Element|Document|Window=} node\n\t * @param {string} `Width` or `Height` property.\n\t * @return {number}\n\t * @protected\n\t */\n\tstatic getClientSize_(node, prop) {\n\t\tvar el = node;\n\t\tif (core.isWindow(node)) {\n\t\t\tel = node.document.documentElement;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\tel = node.documentElement;\n\t\t}\n\t\treturn el['client' + prop];\n\t}\n\n\t/**\n\t * Gets the client width of the specified node. Scroll width is not\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getClientWidth(node) {\n\t\treturn this.getClientSize_(node, 'Width');\n\t}\n\n\t/**\n\t * Gets the region of the element, document or window.\n\t * @param {Element|Document|Window=} opt_element Optional element to test.\n\t * @return {!DOMRect} The returned value is a simulated DOMRect object which\n\t *     is the union of the rectangles returned by getClientRects() for the\n\t *     element, i.e., the CSS border-boxes associated with the element.\n\t * @protected\n\t */\n\tstatic getDocumentRegion_(opt_element) {\n\t\tvar height = this.getHeight(opt_element);\n\t\tvar width = this.getWidth(opt_element);\n\t\treturn this.makeRegion(height, height, 0, width, 0, width);\n\t}\n\n\t/**\n\t * Gets the height of the specified node. Scroll height is included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getHeight(node) {\n\t\treturn this.getSize_(node, 'Height');\n\t}\n\n\t/**\n\t * Gets the top offset position of the given node. This fixes the `offsetLeft` value of\n\t * nodes that were translated, which don't take that into account at all. That makes\n\t * the calculation more expensive though, so if you don't want that to be considered\n\t * either pass `opt_ignoreTransform` as true or call `offsetLeft` directly on the node.\n\t * @param {!Element} node\n\t * @param {boolean=} opt_ignoreTransform When set to true will ignore transform css\n\t *   when calculating the position. Defaults to false.\n\t * @return {number}\n\t */\n\tstatic getOffsetLeft(node, opt_ignoreTransform) {\n\t\treturn node.offsetLeft + (opt_ignoreTransform ? 0 : Position.getTranslation(node).left);\n\t}\n\n\t/**\n\t * Gets the top offset position of the given node. This fixes the `offsetTop` value of\n\t * nodes that were translated, which don't take that into account at all. That makes\n\t * the calculation more expensive though, so if you don't want that to be considered\n\t * either pass `opt_ignoreTransform` as true or call `offsetTop` directly on the node.\n\t * @param {!Element} node\n\t * @param {boolean=} opt_ignoreTransform When set to true will ignore transform css\n\t *   when calculating the position. Defaults to false.\n\t * @return {number}\n\t */\n\tstatic getOffsetTop(node, opt_ignoreTransform) {\n\t\treturn node.offsetTop + (opt_ignoreTransform ? 0 : Position.getTranslation(node).top);\n\t}\n\n\t/**\n\t * Gets the size of an element and its position relative to the viewport.\n\t * @param {!Document|Element|Window} node\n\t * @param {boolean=} opt_includeScroll Flag indicating if the document scroll\n\t *   position should be considered in the element's region coordinates. Defaults\n\t *   to false.\n\t * @return {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t */\n\tstatic getRegion(node, opt_includeScroll) {\n\t\tif (core.isDocument(node) || core.isWindow(node)) {\n\t\t\treturn this.getDocumentRegion_(node);\n\t\t}\n\t\treturn this.makeRegionFromBoundingRect_(node.getBoundingClientRect(), opt_includeScroll);\n\t}\n\n\t/**\n\t * Gets the scroll left position of the specified node.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getScrollLeft(node) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn node.pageXOffset;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\treturn node.defaultView.pageXOffset;\n\t\t}\n\t\treturn node.scrollLeft;\n\t}\n\n\t/**\n\t * Gets the scroll top position of the specified node.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getScrollTop(node) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn node.pageYOffset;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\treturn node.defaultView.pageYOffset;\n\t\t}\n\t\treturn node.scrollTop;\n\t}\n\n\t/**\n\t * Gets the height or width of the specified node. Scroll height is\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @param {string} `Width` or `Height` property.\n\t * @return {number}\n\t * @protected\n\t */\n\tstatic getSize_(node, prop) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn this.getClientSize_(node, prop);\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\tvar docEl = node.documentElement;\n\t\t\treturn Math.max(\n\t\t\t\tnode.body['scroll' + prop], docEl['scroll' + prop],\n\t\t\t\tnode.body['offset' + prop], docEl['offset' + prop], docEl['client' + prop]);\n\t\t}\n\t\treturn Math.max(node['client' + prop], node['scroll' + prop], node['offset' + prop]);\n\t}\n\n\t/**\n\t * Gets the transform matrix values for the given node.\n\t * @param {!Element} node\n\t * @return {Array<number>}\n\t */\n\tstatic getTransformMatrixValues(node) {\n\t\tvar style = getComputedStyle(node);\n\t\tvar transform = style.msTransform || style.transform || style.webkitTransform || style.mozTransform;\n\t\tif (transform !== 'none') {\n\t\t\tvar values = [];\n\t\t\tvar regex = /([\\d-\\.\\s]+)/g;\n\t\t\tvar matches = regex.exec(transform);\n\t\t\twhile (matches) {\n\t\t\t\tvalues.push(matches[1]);\n\t\t\t\tmatches = regex.exec(transform);\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the number of translated pixels for the given node, for both the top and\n\t * left positions.\n\t * @param {!Element} node\n\t * @return {number}\n\t */\n\tstatic getTranslation(node) {\n\t\tvar values = Position.getTransformMatrixValues(node);\n\t\tvar translation = {\n\t\t\tleft: 0,\n\t\t\ttop: 0\n\t\t};\n\t\tif (values) {\n\t\t\ttranslation.left = parseFloat(values.length === 6 ? values[4] : values[13]);\n\t\t\ttranslation.top = parseFloat(values.length === 6 ? values[5] : values[14]);\n\t\t}\n\t\treturn translation;\n\t}\n\n\t/**\n\t * Gets the width of the specified node. Scroll width is included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getWidth(node) {\n\t\treturn this.getSize_(node, 'Width');\n\t}\n\n\t/**\n\t * Tests if a region intersects with another.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {boolean}\n\t */\n\tstatic intersectRegion(r1, r2) {\n\t\treturn Geometry.intersectRect(\n\t\t\tr1.top, r1.left, r1.bottom, r1.right,\n\t\t\tr2.top, r2.left, r2.bottom, r2.right);\n\t}\n\n\t/**\n\t * Tests if a region is inside another.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {boolean}\n\t */\n\tstatic insideRegion(r1, r2) {\n\t\treturn (r2.top >= r1.top) && (r2.bottom <= r1.bottom) &&\n\t\t\t(r2.right <= r1.right) && (r2.left >= r1.left);\n\t}\n\n\t/**\n\t * Tests if a region is inside viewport region.\n\t * @param {DOMRect} region\n\t * @return {boolean}\n\t */\n\tstatic insideViewport(region) {\n\t\treturn this.insideRegion(this.getRegion(window), region);\n\t}\n\n\t/**\n\t * Computes the intersection region between two regions.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {?DOMRect} Intersection region or null if regions doesn't\n\t *     intersects.\n\t */\n\tstatic intersection(r1, r2) {\n\t\tif (!this.intersectRegion(r1, r2)) {\n\t\t\treturn null;\n\t\t}\n\t\tvar bottom = Math.min(r1.bottom, r2.bottom);\n\t\tvar right = Math.min(r1.right, r2.right);\n\t\tvar left = Math.max(r1.left, r2.left);\n\t\tvar top = Math.max(r1.top, r2.top);\n\t\treturn this.makeRegion(bottom, bottom - top, left, right, top, right - left);\n\t}\n\n\t/**\n\t * Makes a region object. It's a writable version of DOMRect.\n\t * @param {number} bottom\n\t * @param {number} height\n\t * @param {number} left\n\t * @param {number} right\n\t * @param {number} top\n\t * @param {number} width\n\t * @return {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t */\n\tstatic makeRegion(bottom, height, left, right, top, width) {\n\t\treturn {\n\t\t\tbottom: bottom,\n\t\t\theight: height,\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\ttop: top,\n\t\t\twidth: width\n\t\t};\n\t}\n\n\t/**\n\t * Makes a region from a DOMRect result from `getBoundingClientRect`.\n\t * @param  {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t * @param {boolean=} opt_includeScroll Flag indicating if the document scroll\n\t *   position should be considered in the element's region coordinates. Defaults\n\t *   to false.\n\t * @return {DOMRect} Writable version of DOMRect.\n\t * @protected\n\t */\n\tstatic makeRegionFromBoundingRect_(rect, opt_includeScroll) {\n\t\tvar deltaX = opt_includeScroll ? Position.getScrollLeft(document) : 0;\n\t\tvar deltaY = opt_includeScroll ? Position.getScrollTop(document) : 0;\n\t\treturn this.makeRegion(\n\t\t\trect.bottom + deltaY,\n\t\t\trect.height,\n\t\t\trect.left + deltaX,\n\t\t\trect.right + deltaX,\n\t\t\trect.top + deltaY,\n\t\t\trect.width\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the given point coordinates are inside a region.\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {!Object} region\n\t * @return {boolean}\n\t */\n\tstatic pointInsideRegion(x, y, region) {\n\t\treturn Position.insideRegion(region, Position.makeRegion(y, 0, x, x, y, 0));\n\t}\n}\n\nexport default Position;\n"],"sourceRoot":"/source/"}