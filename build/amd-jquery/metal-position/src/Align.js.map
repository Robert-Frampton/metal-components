{"version":3,"sources":["Align.js"],"names":["Align","element","alignElement","position","suggestion","suggestAlignBestRegion","bestRegion","region","computedStyle","window","getComputedStyle","getPropertyValue","top","pageYOffset","left","pageXOffset","offsetParent","getOffsetTop","getOffsetLeft","style","r1","getRegion","r2","TopCenter","height","width","RightCenter","BottomCenter","bottom","LeftCenter","TopRight","right","BottomRight","BottomLeft","TopLeft","val","bestArea","bestPosition","getAlignRegion","tryPosition","tryRegion","viewportRegion","i","intersectRegion","visibleRegion","intersection","area","insideViewport","Top","Right","Bottom","Left"],"mappings":"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","file":"node_modules/metal-position/src/Align.js","sourcesContent":["'use strict';\n\nimport Position from './Position';\n\n/**\n * Align utility. Computes region or best region to align an element with\n * another. Regions are relative to viewport, make sure to use element with\n * position fixed, or position absolute when the element first positioned\n * parent is the body element.\n */\nclass Align {\n\n\t/**\n\t * Aligns the element with the best region around alignElement. The best\n\t * region is defined by clockwise rotation starting from the specified\n\t * `position`. The element is always aligned in the middle of alignElement\n\t * axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {string} The final chosen position for the aligned element.\n\t * @static\n\t */\n\tstatic align(element, alignElement, position) {\n\t\tvar suggestion = this.suggestAlignBestRegion(element, alignElement, position);\n\t\tvar bestRegion = suggestion.region;\n\n\t\tvar computedStyle = window.getComputedStyle(element, null);\n\t\tif (computedStyle.getPropertyValue('position') !== 'fixed') {\n\t\t\tbestRegion.top += window.pageYOffset;\n\t\t\tbestRegion.left += window.pageXOffset;\n\n\t\t\tvar offsetParent = element;\n\t\t\twhile ((offsetParent = offsetParent.offsetParent)) {\n\t\t\t\tbestRegion.top -= Position.getOffsetTop(offsetParent);\n\t\t\t\tbestRegion.left -= Position.getOffsetLeft(offsetParent);\n\t\t\t}\n\t\t}\n\n\t\telement.style.top = bestRegion.top + 'px';\n\t\telement.style.left = bestRegion.left + 'px';\n\t\treturn suggestion.position;\n\t}\n\n\t/**\n\t * Returns the best region to align element with alignElement. This is similar\n\t * to `Align.suggestAlignBestRegion`, but it only returns the region information,\n\t * while `Align.suggestAlignBestRegion` also returns the chosen position.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {DOMRect} Best region to align element.\n\t * @static\n\t */\n\tstatic getAlignBestRegion(element, alignElement, position) {\n\t\treturn Align.suggestAlignBestRegion(element, alignElement, position).region;\n\t}\n\n\t/**\n\t * Returns the region to align element with alignElement. The element is\n\t * always aligned in the middle of alignElement axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The position to align. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {DOMRect} Region to align element.\n\t * @static\n\t */\n\tstatic getAlignRegion(element, alignElement, position) {\n\t\tvar r1 = Position.getRegion(alignElement);\n\t\tvar r2 = Position.getRegion(element);\n\t\tvar top = 0;\n\t\tvar left = 0;\n\n\t\tswitch (position) {\n\t\t\tcase Align.TopCenter:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.left + r1.width / 2 - r2.width / 2;\n\t\t\t\tbreak;\n\t\t\tcase Align.RightCenter:\n\t\t\t\ttop = r1.top + r1.height / 2 - r2.height / 2;\n\t\t\t\tleft = r1.left + r1.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomCenter:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.left + r1.width / 2 - r2.width / 2;\n\t\t\t\tbreak;\n\t\t\tcase Align.LeftCenter:\n\t\t\t\ttop = r1.top + r1.height / 2 - r2.height / 2;\n\t\t\t\tleft = r1.left - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.TopRight:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.right - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomRight:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.right - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomLeft:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.left;\n\t\t\t\tbreak;\n\t\t\tcase Align.TopLeft:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.left;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn {\n\t\t\tbottom: top + r2.height,\n\t\t\theight: r2.height,\n\t\t\tleft: left,\n\t\t\tright: left + r2.width,\n\t\t\ttop: top,\n\t\t\twidth: r2.width\n\t\t};\n\t}\n\n\t/**\n\t * Checks if specified value is a valid position. Options `Align.Top`,\n\t *     `Align.Right`, `Align.Bottom`, `Align.Left`.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} val\n\t * @return {boolean} Returns true if value is a valid position.\n\t * @static\n\t */\n\tstatic isValidPosition(val) {\n\t\treturn 0 <= val && val <= 8;\n\t}\n\n\t/**\n\t * Looks for the best region for aligning the given element. The best\n\t * region is defined by clockwise rotation starting from the specified\n\t * `position`. The element is always aligned in the middle of alignElement\n\t * axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {{position: string, region: DOMRect}} Best region to align element.\n\t * @static\n\t */\n\tstatic suggestAlignBestRegion(element, alignElement, position) {\n\t\tvar bestArea = 0;\n\t\tvar bestPosition = position;\n\t\tvar bestRegion = this.getAlignRegion(element, alignElement, bestPosition);\n\t\tvar tryPosition = bestPosition;\n\t\tvar tryRegion = bestRegion;\n\t\tvar viewportRegion = Position.getRegion(window);\n\n\t\tfor (var i = 0; i < 8;) {\n\t\t\tif (Position.intersectRegion(viewportRegion, tryRegion)) {\n\t\t\t\tvar visibleRegion = Position.intersection(viewportRegion, tryRegion);\n\t\t\t\tvar area = visibleRegion.width * visibleRegion.height;\n\t\t\t\tif (area > bestArea) {\n\t\t\t\t\tbestArea = area;\n\t\t\t\t\tbestRegion = tryRegion;\n\t\t\t\t\tbestPosition = tryPosition;\n\t\t\t\t}\n\t\t\t\tif (Position.insideViewport(tryRegion)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttryPosition = (position + (++i)) % 8;\n\t\t\ttryRegion = this.getAlignRegion(element, alignElement, tryPosition);\n\t\t}\n\n\t\treturn {\n\t\t\tposition: bestPosition,\n\t\t\tregion: bestRegion\n\t\t};\n\t}\n}\n\n/**\n * Constants that represent the supported positions for `Align`.\n * @type {number}\n * @static\n */\n\nAlign.TopCenter = 0;\nAlign.TopRight = 1;\nAlign.RightCenter = 2;\nAlign.BottomRight = 3;\nAlign.BottomCenter = 4;\nAlign.BottomLeft = 5;\nAlign.LeftCenter = 6;\nAlign.TopLeft = 7;\n\n/**\n * Aliases for position constants.\n * @type {number}\n * @static\n */\nAlign.Top = Align.TopCenter;\nAlign.Right = Align.RightCenter;\nAlign.Bottom = Align.BottomCenter;\nAlign.Left = Align.LeftCenter;\n\nexport default Align;\n"],"sourceRoot":"/source/"}