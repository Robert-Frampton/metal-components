{"version":3,"sources":["EventEmitter.js"],"names":["EventEmitter","events_","maxListeners_","shouldUseFacade_","addListener","events","listener","opt_default","validateListener_","normalizeEvents_","i","length","addSingleListener_","event","opt_origin","emit","push","default","fn","origin","listeners","warned","console","warn","disposeInternal","args","slice","arguments","concat","facade","getShouldUseFacade","preventDefault","preventedDefault","target","type","defaultListeners","apply","j","map","many","amount","many_","self","handlerInternal","removeListener","matchesListener_","listenerObj","isString","off","listenerObjs","removeMatchingListenerObjs_","on","once","removeAllListeners","opt_events","splice","setMaxListeners","max","setShouldUseFacade","shouldUseFacade","isFunction","TypeError"],"mappings":"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","file":"node_modules/metal-events/src/EventEmitter.js","sourcesContent":["'use strict';\n\nimport { core, array, Disposable } from 'metal';\nimport EventHandle from './EventHandle';\n\n/**\n * EventEmitter utility.\n * @constructor\n * @extends {Disposable}\n */\nclass EventEmitter extends Disposable {\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Holds event listeners scoped by event type.\n\t\t * @type {!Object<string, !Array<!function()>>}\n\t\t * @protected\n\t\t */\n\t\tthis.events_ = [];\n\n\t\t/**\n\t\t * The maximum number of listeners allowed for each event type. If the number\n\t\t * becomes higher than the max, a warning will be issued.\n\t\t * @type {number}\n\t\t * @protected\n\t\t */\n\t\tthis.maxListeners_ = 10;\n\n\t\t/**\n\t\t * Configuration option which determines if an event facade should be sent\n\t\t * as a param of listeners when emitting events. If set to true, the facade\n\t\t * will be passed as the first argument of the listener.\n\t\t * @type {boolean}\n\t\t * @protected\n\t\t */\n\t\tthis.shouldUseFacade_ = false;\n\t}\n\n\t/**\n\t * Adds a listener to the end of the listeners array for the specified events.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @param {boolean} opt_default Flag indicating if this listener is a default\n\t *   action for this event. Default actions are run last, and only if no previous\n\t *   listener call `preventDefault()` on the received event facade.\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\taddListener(events, listener, opt_default) {\n\t\tthis.validateListener_(listener);\n\n\t\tevents = this.normalizeEvents_(events);\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tthis.addSingleListener_(events[i], listener, opt_default);\n\t\t}\n\n\t\treturn new EventHandle(this, events, listener);\n\t}\n\n\t/**\n\t * Adds a listener to the end of the listeners array for a single event.\n\t * @param {string} event\n\t * @param {!Function} listener\n\t * @param {boolean} opt_default Flag indicating if this listener is a default\n\t *   action for this event. Default actions are run last, and only if no previous\n\t *   listener call `preventDefault()` on the received event facade.\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t * @param {Function=} opt_origin The original function that was added as a\n\t *   listener, if there is any.\n\t * @protected\n\t */\n\taddSingleListener_(event, listener, opt_default, opt_origin) {\n\t\tthis.emit('newListener', event, listener);\n\n\t\tif (!this.events_[event]) {\n\t\t\tthis.events_[event] = [];\n\t\t}\n\t\tthis.events_[event].push({\n\t\t\tdefault: opt_default,\n\t\t\tfn: listener,\n\t\t\torigin: opt_origin\n\t\t});\n\n\t\tvar listeners = this.events_[event];\n\t\tif (listeners.length > this.maxListeners_ && !listeners.warned) {\n\t\t\tconsole.warn(\n\t\t\t\t'Possible EventEmitter memory leak detected. %d listeners added ' +\n\t\t\t\t'for event %s. Use emitter.setMaxListeners() to increase limit.',\n\t\t\t\tlisteners.length,\n\t\t\t\tevent\n\t\t\t);\n\t\t\tlisteners.warned = true;\n\t\t}\n\t}\n\n\t/**\n\t * Disposes of this instance's object references.\n\t * @override\n\t */\n\tdisposeInternal() {\n\t\tthis.events_ = [];\n\t}\n\n\t/**\n\t * Execute each of the listeners in order with the supplied arguments.\n\t * @param {string} event\n\t * @param {*} opt_args [arg1], [arg2], [...]\n\t * @return {boolean} Returns true if event had listeners, false otherwise.\n\t */\n\temit(event) {\n\t\tvar args = array.slice(arguments, 1);\n\t\tvar listeners = (this.events_[event] || []).concat();\n\n\t\tvar facade;\n\t\tif (this.getShouldUseFacade()) {\n\t\t\tfacade = {\n\t\t\t\tpreventDefault: function() {\n\t\t\t\t\tfacade.preventedDefault = true;\n\t\t\t\t},\n\t\t\t\ttarget: this,\n\t\t\t\ttype: event\n\t\t\t};\n\t\t\targs.push(facade);\n\t\t}\n\n\t\tvar defaultListeners = [];\n\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\tif (listeners[i].default) {\n\t\t\t\tdefaultListeners.push(listeners[i]);\n\t\t\t} else {\n\t\t\t\tlisteners[i].fn.apply(this, args);\n\t\t\t}\n\t\t}\n\t\tif (!facade || !facade.preventedDefault) {\n\t\t\tfor (var j = 0; j < defaultListeners.length; j++) {\n\t\t\t\tdefaultListeners[j].fn.apply(this, args);\n\t\t\t}\n\t\t}\n\n\n\t\tif (event !== '*') {\n\t\t\tthis.emit.apply(this, ['*', event].concat(args));\n\t\t}\n\n\t\treturn listeners.length > 0;\n\t}\n\n\t/**\n\t * Gets the configuration option which determines if an event facade should\n\t * be sent as a param of listeners when emitting events. If set to true, the\n\t * facade will be passed as the first argument of the listener.\n\t * @return {boolean}\n\t */\n\tgetShouldUseFacade() {\n\t\treturn this.shouldUseFacade_;\n\t}\n\n\t/**\n\t * Returns an array of listeners for the specified event.\n\t * @param {string} event\n\t * @return {Array} Array of listeners.\n\t */\n\tlisteners(event) {\n\t\treturn (this.events_[event] || []).map(listener => listener.fn);\n\t}\n\n\t/**\n\t * Adds a listener that will be invoked a fixed number of times for the\n\t * events. After each event is triggered the specified amount of times, the\n\t * listener is removed for it.\n\t * @param {!(Array|string)} events\n\t * @param {number} amount The amount of times this event should be listened\n\t * to.\n\t * @param {!Function} listener\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\tmany(events, amount, listener) {\n\t\tevents = this.normalizeEvents_(events);\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tthis.many_(events[i], amount, listener);\n\t\t}\n\n\t\treturn new EventHandle(this, events, listener);\n\t}\n\n\t/**\n\t * Adds a listener that will be invoked a fixed number of times for a single\n\t * event. After the event is triggered the specified amount of times, the\n\t * listener is removed.\n\t * @param {string} event\n\t * @param {number} amount The amount of times this event should be listened\n\t * to.\n\t * @param {!Function} listener\n\t * @protected\n\t */\n\tmany_(event, amount, listener) {\n\t\tvar self = this;\n\n\t\tif (amount <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction handlerInternal() {\n\t\t\tif (--amount === 0) {\n\t\t\t\tself.removeListener(event, handlerInternal);\n\t\t\t}\n\t\t\tlistener.apply(self, arguments);\n\t\t}\n\n\t\tself.addSingleListener_(event, handlerInternal, false, listener);\n\t}\n\n\t/**\n\t * Checks if a listener object matches the given listener function. To match,\n\t * it needs to either point to that listener or have it as its origin.\n\t * @param {!Object} listenerObj\n\t * @param {!Function} listener\n\t * @return {boolean}\n\t * @protected\n\t */\n\tmatchesListener_(listenerObj, listener) {\n\t\treturn listenerObj.fn === listener ||\n\t\t\t(listenerObj.origin && listenerObj.origin === listener);\n\t}\n\n\t/**\n\t * Converts the parameter to an array if only one event is given.\n\t * @param  {!(Array|string)} events\n\t * @return {!Array}\n\t * @protected\n\t */\n\tnormalizeEvents_(events) {\n\t\treturn core.isString(events) ? [events] : events;\n\t}\n\n\t/**\n\t * Removes a listener for the specified events.\n\t * Caution: changes array indices in the listener array behind the listener.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\toff(events, listener) {\n\t\tthis.validateListener_(listener);\n\n\t\tevents = this.normalizeEvents_(events);\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar listenerObjs = this.events_[events[i]] || [];\n\t\t\tthis.removeMatchingListenerObjs_(listenerObjs, listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a listener to the end of the listeners array for the specified events.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\ton() {\n\t\treturn this.addListener.apply(this, arguments);\n\t}\n\n\t/**\n\t * Adds a one time listener for the events. This listener is invoked only the\n\t * next time each event is fired, after which it is removed.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\tonce(events, listener) {\n\t\treturn this.many(events, 1, listener);\n\t}\n\n\t/**\n\t * Removes all listeners, or those of the specified events. It's not a good\n\t * idea to remove listeners that were added elsewhere in the code,\n\t * especially when it's on an emitter that you didn't create.\n\t * @param {(Array|string)=} opt_events\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\tremoveAllListeners(opt_events) {\n\t\tif (opt_events) {\n\t\t\tvar events = this.normalizeEvents_(opt_events);\n\t\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\t\tthis.events_[events[i]] = null;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.events_ = {};\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all listener objects from the given array that match the given\n\t * listener function.\n\t * @param {!Array.<Object>} listenerObjs\n\t * @param {!Function} listener\n\t * @protected\n\t */\n\tremoveMatchingListenerObjs_(listenerObjs, listener) {\n\t\tfor (var i = listenerObjs.length - 1; i >= 0; i--) {\n\t\t\tif (this.matchesListener_(listenerObjs[i], listener)) {\n\t\t\t\tlistenerObjs.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes a listener for the specified events.\n\t * Caution: changes array indices in the listener array behind the listener.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\tremoveListener() {\n\t\treturn this.off.apply(this, arguments);\n\t}\n\n\t/**\n\t * By default EventEmitters will print a warning if more than 10 listeners\n\t * are added for a particular event. This is a useful default which helps\n\t * finding memory leaks. Obviously not all Emitters should be limited to 10.\n\t * This function allows that to be increased. Set to zero for unlimited.\n\t * @param {number} max The maximum number of listeners.\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\tsetMaxListeners(max) {\n\t\tthis.maxListeners_ = max;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the configuration option which determines if an event facade should\n\t * be sent as a param of listeners when emitting events. If set to true, the\n\t * facade will be passed as the first argument of the listener.\n\t * @param {boolean} shouldUseFacade\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\tsetShouldUseFacade(shouldUseFacade) {\n\t\tthis.shouldUseFacade_ = shouldUseFacade;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Checks if the given listener is valid, throwing an exception when it's not.\n\t * @param  {*} listener\n\t * @protected\n\t */\n\tvalidateListener_(listener) {\n\t\tif (!core.isFunction(listener)) {\n\t\t\tthrow new TypeError('Listener must be a function');\n\t\t}\n\t}\n}\n\nexport default EventEmitter;\n"],"sourceRoot":"/source/"}