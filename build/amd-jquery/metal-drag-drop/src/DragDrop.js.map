{"version":3,"sources":["DragDrop.js"],"names":["DragDrop","opt_config","activeTargets_","addTarget","target","targets","push","buildEventObject_","obj","allActiveTargets","cleanUpAfterDragging_","forEach","removeAttribute","length","removeClasses","targetOverClass","findAllActiveTargets_","activeTargets","mainRegion","sourceRegion","getSourceRegion_","index","region","getRegion","activeDragPlaceholder_","intersectRegion","insideRegion","concat","bind","isDefAndNotNull","mousePos_","x","y","makeRegion","mixin","sourceRegion_","left","document","body","scrollLeft","right","top","scrollTop","bottom","handleContainerChanged_","data","event","prevTargetsSelector_","removeTarget","remove","setterTargetsFn_","val","isString","toElements_","startDragging_","ariaDropEffect","setAttribute","updatePosition","deltaX","deltaY","newTargets","emit","Events","TARGET_LEAVE","addClasses","TARGET_ENTER","STATE","validator","value","setter","DRAG","END"],"mappings":"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","file":"node_modules/metal-drag-drop/src/DragDrop.js","sourcesContent":["'use strict';\n\nimport { array, core, object } from 'metal';\nimport dom from 'metal-dom';\nimport Drag from './Drag';\nimport Position from 'metal-position';\nimport 'metal-events';\n\n/**\n * Adds the functionality of dropping dragged elements to specific\n * targets to the `Drag` class.\n * @extends {Drag}\n */\nclass DragDrop extends Drag {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor(opt_config) {\n\t\tsuper(opt_config);\n\n\t\t/**\n\t\t * The currently active targets, that is, the ones that the dragged source is over.\n\t\t * @type {!Array<!Element>}\n\t\t * @protected\n\t\t */\n\t\tthis.activeTargets_ = [];\n\t}\n\n\t/**\n\t * Adds a target to this `DragDrop` instance.\n\t * @param {!Element} target\n\t */\n\taddTarget(target) {\n\t\tthis.targets.push(target);\n\t\tthis.targets = this.targets;\n\t}\n\n\t/**\n\t * Overrides the original method from `Drag` to include the target on the event object.\n\t * @return {!Object}\n\t * @protected\n\t * @override\n\t */\n\tbuildEventObject_() {\n\t\tvar obj = super.buildEventObject_();\n\t\tobj.target = this.activeTargets_[0];\n\t\tobj.allActiveTargets = this.activeTargets_;\n\t\treturn obj;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tcleanUpAfterDragging_() {\n\t\tsuper.cleanUpAfterDragging_();\n\t\tthis.targets.forEach(target => target.removeAttribute('aria-dropeffect'));\n\t\tif (this.activeTargets_.length) {\n\t\t\tdom.removeClasses(this.activeTargets_[0], this.targetOverClass);\n\t\t}\n\t\tthis.activeTargets_ = [];\n\t}\n\n\t/**\n\t * Finds all targets that the dragged element is currently over.\n\t * @return {!Array<!Element>} The current active targets.\n\t * @protected\n\t */\n\tfindAllActiveTargets_() {\n\t\tvar activeTargets = [];\n\t\tvar mainRegion;\n\t\tvar sourceRegion = this.getSourceRegion_();\n\t\tvar targets = this.targets;\n\t\ttargets.forEach(function(target, index) {\n\t\t\tvar region = Position.getRegion(target);\n\t\t\tif (targets[index] !== this.activeDragPlaceholder_ && Position.intersectRegion(region, sourceRegion)) {\n\t\t\t\tif (!mainRegion || Position.insideRegion(mainRegion, region)) {\n\t\t\t\t\tactiveTargets = [targets[index]].concat(activeTargets);\n\t\t\t\t\tmainRegion = region;\n\t\t\t\t} else {\n\t\t\t\t\tactiveTargets.push(targets[index]);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this));\n\t\treturn activeTargets;\n\t}\n\n\t/**\n\t * Gets the active source's region, to be used when calculating which targets are active.\n\t * @return {!Object}\n\t * @protected\n\t */\n\tgetSourceRegion_() {\n\t\tif (core.isDefAndNotNull(this.mousePos_)) {\n\t\t\tvar x = this.mousePos_.x;\n\t\t\tvar y = this.mousePos_.y;\n\t\t\treturn Position.makeRegion(y, 0, x, x, y, 0);\n\t\t} else {\n\t\t\t// We need to remove the scroll data from the region, since the other regions we'll\n\t\t\t// be comparing to won't take that information into account.\n\t\t\tvar region = object.mixin({}, this.sourceRegion_);\n\t\t\tregion.left -= document.body.scrollLeft;\n\t\t\tregion.right -= document.body.scrollLeft;\n\t\t\tregion.top -= document.body.scrollTop;\n\t\t\tregion.bottom -= document.body.scrollTop;\n\t\t\treturn region;\n\t\t}\n\t}\n\n\t/**\n\t * Triggers when the `container` state changes. Overrides default method so\n\t * it will also update `targets` when container changes.\n\t * @param {!Object} data\n\t * @param {!Object} event\n\t * @protected\n\t */\n\thandleContainerChanged_(data, event) {\n\t\tsuper.handleContainerChanged_(data, event);\n\t\tif (this.prevTargetsSelector_) {\n\t\t\tthis.targets = this.prevTargetsSelector_;\n\t\t}\n\t}\n\n\t/**\n\t * Removes a target from this `DragDrop` instance.\n\t * @param {!Element} target\n\t */\n\tremoveTarget(target) {\n\t\tarray.remove(this.targets, target);\n\t\tthis.targets = this.targets;\n\t}\n\n\t/**\n\t * Sets the `targets` state property.\n\t * @param {Element|string} val\n\t * @return {!Array<!Element>}\n\t * @protected\n\t */\n\tsetterTargetsFn_(val) {\n\t\tthis.prevTargetsSelector_ = core.isString(val) ? val : null;\n\t\treturn this.toElements_(val);\n\t}\n\n\t/**\n\t * Overrides the original method from `Drag` to also set the \"aria-dropeffect\"\n\t * attribute, if set, for all targets.\n\t * @return {[type]} [description]\n\t */\n\tstartDragging_() {\n\t\tif (this.ariaDropEffect) {\n\t\t\tthis.targets.forEach(target => target.setAttribute('aria-dropeffect', this.ariaDropEffect));\n\t\t}\n\t\tsuper.startDragging_();\n\t}\n\n\t/**\n\t * Overrides original method from `Drag` to also be enable finding the target\n\t * the dragged element is over at the new position.\n\t * @param {number} deltaX\n\t * @param {number} deltaY\n\t * @override\n\t */\n\tupdatePosition(deltaX, deltaY) {\n\t\tsuper.updatePosition(deltaX, deltaY);\n\n\t\tvar newTargets = this.findAllActiveTargets_();\n\t\tif (newTargets[0] !== this.activeTargets_[0]) {\n\t\t\tif (this.activeTargets_[0]) {\n\t\t\t\tdom.removeClasses(this.activeTargets_[0], this.targetOverClass);\n\t\t\t\tthis.emit(DragDrop.Events.TARGET_LEAVE, this.buildEventObject_());\n\t\t\t}\n\n\t\t\tthis.activeTargets_ = newTargets;\n\t\t\tif (this.activeTargets_[0]) {\n\t\t\t\tdom.addClasses(this.activeTargets_[0], this.targetOverClass);\n\t\t\t\tthis.emit(DragDrop.Events.TARGET_ENTER, this.buildEventObject_());\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * State definition.\n * @type {!Object}\n * @static\n */\nDragDrop.STATE = {\n\t/**\n\t * The \"aria-dropeffect\" value to be set for all targets. If not set,\n\t * this html attribute will have to be set manually on the targets.\n\t * @type {string}\n\t */\n\tariaDropEffect: {\n\t\tvalidator: core.isString\n\t},\n\n\t/**\n\t * The CSS class that should be added to drop targets when a source\n\t * is being dragged over them.\n\t * @type {string}\n\t * @default 'dropOver'\n\t */\n\ttargetOverClass: {\n\t\tvalidator: core.isString,\n\t\tvalue: 'targetOver'\n\t},\n\n\t/**\n\t * Elements that the sources can be dropped on. Can be either a single\n\t * element or a selector for multiple elements.\n\t * @type {!Element|string}\n\t */\n\ttargets: {\n\t\tsetter: 'setterTargetsFn_',\n\t\tvalidator: 'validateElementOrString_'\n\t}\n};\n\n/**\n * Holds the names of events that can be emitted by `DragDrop`.\n * @type {!Object}\n * @static\n */\nDragDrop.Events = {\n\tDRAG: 'drag',\n\tEND: 'end',\n\tTARGET_ENTER: 'targetEnter',\n\tTARGET_LEAVE: 'targetLeave'\n};\n\nexport default DragDrop;\n"],"sourceRoot":"/source/"}