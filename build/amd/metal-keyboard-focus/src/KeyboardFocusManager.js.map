{"version":3,"sources":["KeyboardFocusManager.js"],"names":["KeyboardFocusManager","component","opt_selector","component_","selector_","handleKey_","bind","prefix","position","stop","increment","initialPosition","element","ref","increment_","buildRef_","refs","isFocusable_","event","focusHandler_","handleKeyDefault_","originalValue","isElement","focus","emit","EVENT_FOCUSED","isString","delegateTarget","getAttribute","matches","REF_REGEX","exec","parseInt","substr","length","keyCode","getNextFocusable_","size","circularLength_","isNumber","circularLength","focusHandler","handle_","delegate","removeListener"],"mappings":"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","file":"node_modules/metal-keyboard-focus/src/KeyboardFocusManager.js","sourcesContent":["'use strict';\n\nimport core from 'metal';\nimport EventEmitter from 'metal-events';\n\n/**\n * Listens to keyboard events and uses them to move focus between different\n * elements from a component (via the arrow keys for example).\n * By default `KeyboardFocusManager` will assume that all focusable elements\n * in the component will have refs that follow the pattern in\n * KeyboardFocusManager.REF_REGEX, which includes a position number. The arrow\n * keys will then automatically move between elements by\n * incrementing/decrementing this position.\n * It's possible to fully customize this behavior by passing a function to\n * `setFocusHandler`. For more details check this function's docs.\n */\nclass KeyboardFocusManager extends EventEmitter {\n\t/**\n\t * Constructor for `KeyboardFocusManager`.\n\t * @param {!Component} component\n\t * @param {string=} opt_selector\n\t */\n\tconstructor(component, opt_selector) {\n\t\tsuper();\n\t\tthis.component_ = component;\n\t\tthis.selector_ = opt_selector || '*';\n\t\tthis.handleKey_ = this.handleKey_.bind(this);\n\t}\n\n\t/**\n\t * Builds a ref string for the given position.\n\t * @param {string} prefix\n\t * @param {number|string} position\n\t * @return {string}\n\t * @protected\n\t */\n\tbuildRef_(prefix, position) {\n\t\treturn prefix + position;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tthis.stop();\n\t\tthis.component_ = null;\n\t\tthis.selector_ = null;\n\t}\n\n\t/**\n\t * Gets the next focusable element, that is, the next element that doesn't\n\t * have the `data-unfocusable` attribute set to `true`.\n\t * @param {string} prefix\n\t * @param {number} position\n\t * @param {number} increment\n\t * @return {string}\n\t * @protected\n\t */\n\tgetNextFocusable_(prefix, position, increment) {\n\t\tconst initialPosition = position;\n\t\tlet element;\n\t\tlet ref;\n\t\tdo {\n\t\t\tposition = this.increment_(position, increment);\n\t\t\tref = this.buildRef_(prefix, position);\n\t\t\telement = this.component_.refs[ref];\n\t\t} while (this.isFocusable_(element) && position !== initialPosition);\n\t\treturn element ? ref : null;\n\t}\n\n\t/**\n\t * Handles a `keydown` event. Decides if a new element should be focused\n\t * according to the key that was pressed.\n\t * @param {!Event} event\n\t * @protected\n\t */\n\thandleKey_(event) {\n\t\tlet element = this.focusHandler_ && this.focusHandler_(event);\n\t\tif (!this.focusHandler_ || element === true) {\n\t\t\telement = this.handleKeyDefault_(event);\n\t\t}\n\n\t\tconst originalValue = element;\n\t\tif (!core.isElement(element)) {\n\t\t\telement = this.component_.refs[element];\n\t\t}\n\t\tif (element) {\n\t\t\telement.focus();\n\t\t\tthis.emit(KeyboardFocusManager.EVENT_FOCUSED, {\n\t\t\t\telement,\n\t\t\t\tref: core.isString(originalValue) ? originalValue : null\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Handles a key press according to the default behavior. Assumes that all\n\t * focusable elements in the component will have refs that follow the pattern\n\t * in KeyboardFocusManager.REF_REGEX, which includes a position number. The\n\t * arrow keys will then automatically move between elements by\n\t * incrementing/decrementing the position.\n\t * @param {!Event} event\n\t * @protected\n\t */\n\thandleKeyDefault_(event) {\n\t\tconst ref = event.delegateTarget.getAttribute('ref');\n\t\tconst matches = KeyboardFocusManager.REF_REGEX.exec(ref);\n\t\tif (!matches) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet position = parseInt(matches[1], 10);\n\t\tconst prefix = ref.substr(0, ref.length - matches[1].length);\n\t\tswitch (event.keyCode) {\n\t\t\tcase 37:\n\t\t\tcase 38:\n\t\t\t\t// Left/up arrow keys will focus the previous element.\n\t\t\t\treturn this.getNextFocusable_(prefix, position, -1);\n\t\t\tcase 39:\n\t\t\tcase 40:\n\t\t\t\t// Right/down arrow keys will focus the next element.\n\t\t\t\treturn this.getNextFocusable_(prefix, position, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Increments the given position, making sure to follow circular rules if\n\t * enabled.\n\t * @param {number} position\n\t * @param {number} increment\n\t * @return {number}\n\t * @protected\n\t */\n\tincrement_(position, increment) {\n\t\tconst size = this.circularLength_;\n\t\tposition += increment;\n\t\tif (core.isNumber(size)) {\n\t\t\tif (position < 0) {\n\t\t\t\tposition = size - 1;\n\t\t\t} else if (position >= size) {\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\t\treturn position;\n\t}\n\n\t/**\n\t * Checks if the given element is focusable.\n\t * @param {Element} element\n\t * @return {boolean}\n\t * @protected\n\t */\n\tisFocusable_(element) {\n\t\treturn element && element.getAttribute('data-unfocusable') === 'true';\n\t}\n\n\t/**\n\t * Sets the length of the focusable elements. If a number is passed, the\n\t * default focusing behavior will follow a circular pattern, going from the\n\t * last to the first element, and vice versa.\n\t * @param {?number} circularLength\n\t * @chainable\n\t */\n\tsetCircularLength(circularLength) {\n\t\tthis.circularLength_ = circularLength;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets a handler function that will be called to decide which element should\n\t * be focused according to the key that was pressed. It will receive the key\n\t * event and should return one of the following:\n\t *   - `true`, if the default behavior should be triggered instead.\n\t *   - A string, representing a `ref` to the component element that should be\n\t *       focused.\n\t *   - The element itself that should be focused.\n\t *   - Anything else, if nothing should be focused (skipping default behavior\n\t *       too).\n\t * @param {function(key: string)} focusHandler\n\t * @chainable\n\t */\n\tsetFocusHandler(focusHandler) {\n\t\tthis.focusHandler_ = focusHandler;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Starts listening to keyboard events and handling element focus.\n\t * @chainable\n\t */\n\tstart() {\n\t\tif (!this.handle_) {\n\t\t\tthis.handle_ = this.component_.delegate(\n\t\t\t\t'keydown',\n\t\t\t\tthis.selector_,\n\t\t\t\tthis.handleKey_\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stops listening to keyboard events and handling element focus.\n\t * @chainable\n\t */\n\tstop() {\n\t\tif (this.handle_) {\n\t\t\tthis.handle_.removeListener();\n\t\t\tthis.handle_ = null;\n\t\t}\n\t\treturn this;\n\t}\n}\n\n// Event emitted when a selected element was focused via the keyboard.\nKeyboardFocusManager.EVENT_FOCUSED = 'focused';\n\n// The regex used to extract the position from an element's ref.\nKeyboardFocusManager.REF_REGEX = /.+-(\\d+)$/;\n\nexport default KeyboardFocusManager;\n"],"sourceRoot":"/source/"}