{"version":3,"sources":["KeyboardFocusManager.js"],"names":["KeyboardFocusManager","component","opt_selector","component_","selector_","handleKey_","bind","buildRef_","prefix","position","disposeInternal","stop","getNextFocusable_","increment","initialPosition","element","ref","increment_","refs","isFocusable_","event","focusHandler_","handleKeyDefault_","originalValue","isElement","focus","emit","EVENT_FOCUSED","isString","delegateTarget","getAttribute","matches","REF_REGEX","exec","parseInt","substr","length","keyCode","size","circularLength_","isNumber","setCircularLength","circularLength","setFocusHandler","focusHandler","start","handle_","delegate","removeListener"],"mappings":"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","file":"node_modules/metal-keyboard-focus/src/KeyboardFocusManager.js","sourcesContent":["'use strict';\n\nimport core from 'metal';\nimport EventEmitter from 'metal-events';\n\n/**\n * Listens to keyboard events and uses them to move focus between different\n * elements from a component (via the arrow keys for example).\n * By default `KeyboardFocusManager` will assume that all focusable elements\n * in the component will have refs that follow the pattern in\n * KeyboardFocusManager.REF_REGEX, which includes a position number. The arrow\n * keys will then automatically move between elements by\n * incrementing/decrementing this position.\n * It's possible to fully customize this behavior by passing a function to\n * `setFocusHandler`. For more details check this function's docs.\n */\nclass KeyboardFocusManager extends EventEmitter {\n\t/**\n\t * Constructor for `KeyboardFocusManager`.\n\t * @param {!Component} component\n\t * @param {string=} opt_selector\n\t */\n\tconstructor(component, opt_selector) {\n\t\tsuper();\n\t\tthis.component_ = component;\n\t\tthis.selector_ = opt_selector || '*';\n\t\tthis.handleKey_ = this.handleKey_.bind(this);\n\t}\n\n\t/**\n\t * Builds a ref string for the given position.\n\t * @param {string} prefix\n\t * @param {number|string} position\n\t * @return {string}\n\t * @protected\n\t */\n\tbuildRef_(prefix, position) {\n\t\treturn prefix + position;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tthis.stop();\n\t\tthis.component_ = null;\n\t\tthis.selector_ = null;\n\t}\n\n\t/**\n\t * Gets the next focusable element, that is, the next element that doesn't\n\t * have the `data-unfocusable` attribute set to `true`.\n\t * @param {string} prefix\n\t * @param {number} position\n\t * @param {number} increment\n\t * @return {string}\n\t * @protected\n\t */\n\tgetNextFocusable_(prefix, position, increment) {\n\t\tconst initialPosition = position;\n\t\tlet element;\n\t\tlet ref;\n\t\tdo {\n\t\t\tposition = this.increment_(position, increment);\n\t\t\tref = this.buildRef_(prefix, position);\n\t\t\telement = this.component_.refs[ref];\n\t\t} while (this.isFocusable_(element) && position !== initialPosition);\n\t\treturn element ? ref : null;\n\t}\n\n\t/**\n\t * Handles a `keydown` event. Decides if a new element should be focused\n\t * according to the key that was pressed.\n\t * @param {!Event} event\n\t * @protected\n\t */\n\thandleKey_(event) {\n\t\tlet element = this.focusHandler_ && this.focusHandler_(event);\n\t\tif (!this.focusHandler_ || element === true) {\n\t\t\telement = this.handleKeyDefault_(event);\n\t\t}\n\n\t\tconst originalValue = element;\n\t\tif (!core.isElement(element)) {\n\t\t\telement = this.component_.refs[element];\n\t\t}\n\t\tif (element) {\n\t\t\telement.focus();\n\t\t\tthis.emit(KeyboardFocusManager.EVENT_FOCUSED, {\n\t\t\t\telement,\n\t\t\t\tref: core.isString(originalValue) ? originalValue : null\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Handles a key press according to the default behavior. Assumes that all\n\t * focusable elements in the component will have refs that follow the pattern\n\t * in KeyboardFocusManager.REF_REGEX, which includes a position number. The\n\t * arrow keys will then automatically move between elements by\n\t * incrementing/decrementing the position.\n\t * @param {!Event} event\n\t * @protected\n\t */\n\thandleKeyDefault_(event) {\n\t\tconst ref = event.delegateTarget.getAttribute('ref');\n\t\tconst matches = KeyboardFocusManager.REF_REGEX.exec(ref);\n\t\tif (!matches) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet position = parseInt(matches[1], 10);\n\t\tconst prefix = ref.substr(0, ref.length - matches[1].length);\n\t\tswitch (event.keyCode) {\n\t\t\tcase 37:\n\t\t\tcase 38:\n\t\t\t\t// Left/up arrow keys will focus the previous element.\n\t\t\t\treturn this.getNextFocusable_(prefix, position, -1);\n\t\t\tcase 39:\n\t\t\tcase 40:\n\t\t\t\t// Right/down arrow keys will focus the next element.\n\t\t\t\treturn this.getNextFocusable_(prefix, position, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Increments the given position, making sure to follow circular rules if\n\t * enabled.\n\t * @param {number} position\n\t * @param {number} increment\n\t * @return {number}\n\t * @protected\n\t */\n\tincrement_(position, increment) {\n\t\tconst size = this.circularLength_;\n\t\tposition += increment;\n\t\tif (core.isNumber(size)) {\n\t\t\tif (position < 0) {\n\t\t\t\tposition = size - 1;\n\t\t\t} else if (position >= size) {\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\t\treturn position;\n\t}\n\n\t/**\n\t * Checks if the given element is focusable.\n\t * @param {Element} element\n\t * @return {boolean}\n\t * @protected\n\t */\n\tisFocusable_(element) {\n\t\treturn element && element.getAttribute('data-unfocusable') === 'true';\n\t}\n\n\t/**\n\t * Sets the length of the focusable elements. If a number is passed, the\n\t * default focusing behavior will follow a circular pattern, going from the\n\t * last to the first element, and vice versa.\n\t * @param {?number} circularLength\n\t * @chainable\n\t */\n\tsetCircularLength(circularLength) {\n\t\tthis.circularLength_ = circularLength;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets a handler function that will be called to decide which element should\n\t * be focused according to the key that was pressed. It will receive the key\n\t * event and should return one of the following:\n\t *   - `true`, if the default behavior should be triggered instead.\n\t *   - A string, representing a `ref` to the component element that should be\n\t *       focused.\n\t *   - The element itself that should be focused.\n\t *   - Anything else, if nothing should be focused (skipping default behavior\n\t *       too).\n\t * @param {function(key: string)} focusHandler\n\t * @chainable\n\t */\n\tsetFocusHandler(focusHandler) {\n\t\tthis.focusHandler_ = focusHandler;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Starts listening to keyboard events and handling element focus.\n\t * @chainable\n\t */\n\tstart() {\n\t\tif (!this.handle_) {\n\t\t\tthis.handle_ = this.component_.delegate(\n\t\t\t\t'keydown',\n\t\t\t\tthis.selector_,\n\t\t\t\tthis.handleKey_\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stops listening to keyboard events and handling element focus.\n\t * @chainable\n\t */\n\tstop() {\n\t\tif (this.handle_) {\n\t\t\tthis.handle_.removeListener();\n\t\t\tthis.handle_ = null;\n\t\t}\n\t\treturn this;\n\t}\n}\n\n// Event emitted when a selected element was focused via the keyboard.\nKeyboardFocusManager.EVENT_FOCUSED = 'focused';\n\n// The regex used to extract the position from an element's ref.\nKeyboardFocusManager.REF_REGEX = /.+-(\\d+)$/;\n\nexport default KeyboardFocusManager;\n"],"sourceRoot":"/source/"}