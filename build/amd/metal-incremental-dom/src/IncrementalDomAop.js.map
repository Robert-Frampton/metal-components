{"version":3,"sources":["IncrementalDomAop.js"],"names":["IncrementalDomAop","getOriginalFns","fnStack","startInterception","fns","originals","map","name","value","bind","push","mixin","attr","fnAttr","elementOpenEnd","fnOpenEnd","elementOpenStart","fnOpenStart","elementVoid","fnVoid","stopInterception","length","pop","IncrementalDOM","attributes","symbols","default","elementClose","elementOpen","text","collectedArgs","tag","key","statics","getFn","apply","arguments","handleCall","slice"],"mappings":"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","file":"node_modules/metal-incremental-dom/src/IncrementalDomAop.js","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport { array, object } from 'metal';\n\n/**\n * Class responsible for intercepting incremental dom functions through AOP.\n */\nclass IncrementalDomAop {\n\t/**\n\t * Gets the original functions that are intercepted by `IncrementalDomAop`.\n\t * @return {!Object}\n\t */\n\tstatic getOriginalFns() {\n\t\treturn fnStack[0];\n\t}\n\n\t/**\n\t * Starts intercepting calls to incremental dom, replacing them with the given\n\t * functions. Note that `elementVoid`, `elementOpenStart`, `elementOpenEnd`\n\t * and `attr` are the only ones that can't be intercepted, since they'll\n\t * automatically be converted into equivalent calls to `elementOpen` and\n\t * `elementClose`.\n\t * @param {!Object} fns Functions to be called instead of the original ones\n\t *     from incremental DOM. Should be given as a map from the function name\n\t *     to the function that should intercept it. All interceptors will receive\n\t *     the original function as the first argument, the actual arguments from\n\t *     from the original call following it.\n\t */\n\tstatic startInterception(fns) {\n\t\tvar originals = IncrementalDomAop.getOriginalFns();\n\t\tfns = object.map(fns, (name, value) => value.bind(null, originals[name]));\n\t\tfnStack.push(object.mixin({}, originals, fns, {\n\t\t\tattr: fnAttr,\n\t\t\telementOpenEnd: fnOpenEnd,\n\t\t\telementOpenStart: fnOpenStart,\n\t\t\telementVoid: fnVoid\n\t\t}));\n\t}\n\n\t/**\n\t * Restores the original `elementOpen` function from incremental dom to the\n\t * implementation it used before the last call to `startInterception`.\n\t */\n\tstatic stopInterception() {\n\t\tif (fnStack.length > 1) {\n\t\t\tfnStack.pop();\n\t\t}\n\t}\n}\n\nvar fnStack = [{\n\tattr: IncrementalDOM.attr,\n\tattributes: IncrementalDOM.attributes[IncrementalDOM.symbols.default],\n\telementClose: IncrementalDOM.elementClose,\n\telementOpen: IncrementalDOM.elementOpen,\n\telementOpenEnd: IncrementalDOM.elementOpenEnd,\n\telementOpenStart: IncrementalDOM.elementOpenStart,\n\telementVoid: IncrementalDOM.elementVoid,\n\ttext: IncrementalDOM.text\n}];\n\nvar collectedArgs = [];\n\nfunction fnAttr(name, value) {\n\tcollectedArgs.push(name, value);\n}\n\nfunction fnOpenStart(tag, key, statics) {\n\tcollectedArgs = [tag, key, statics];\n}\n\nfunction fnOpenEnd() {\n\treturn getFn('elementOpen').apply(null, collectedArgs);\n}\n\nfunction fnVoid(tag) {\n\tgetFn('elementOpen').apply(null, arguments);\n\treturn getFn('elementClose')(tag);\n}\n\nfunction getFn(name) {\n\treturn fnStack[fnStack.length - 1][name];\n}\n\nfunction handleCall(name) {\n\treturn getFn(name).apply(null, array.slice(arguments, 1));\n}\n\nIncrementalDOM.attr = handleCall.bind(null, 'attr');\nIncrementalDOM.elementClose = handleCall.bind(null, 'elementClose');\nIncrementalDOM.elementOpen = handleCall.bind(null, 'elementOpen');\nIncrementalDOM.elementOpenEnd = handleCall.bind(null, 'elementOpenEnd');\nIncrementalDOM.elementOpenStart = handleCall.bind(null, 'elementOpenStart');\nIncrementalDOM.elementVoid = handleCall.bind(null, 'elementVoid');\nIncrementalDOM.text = handleCall.bind(null, 'text');\n\nIncrementalDOM.attributes[IncrementalDOM.symbols.default] = handleCall.bind(\n\tnull,\n\t'attributes'\n);\n\nexport default IncrementalDomAop;\n"],"sourceRoot":"/source/"}