{"version":3,"sources":["object.js"],"names":["object","mixin","target","key","source","i","arguments","length","getObjectByName","name","opt_obj","scope","window","parts","split","reduce","part","map","obj","fn","mappedObj","keys","Object","shallowEqual","obj1","obj2","keys1","keys2"],"mappings":";AAAA;;;;;;;;;;;;KAEMA,M;;;;;SAOEC,K,kBAAMC,M,EAAQ;AACpB,OAAIC,GAAJ,EAASC,MAAT;AACA,QAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIC,UAAUC,MAA9B,EAAsCF,GAAtC,EAA2C;AAC1CD,aAASE,UAAUD,CAAV,CAAT;AACA,SAAKF,GAAL,IAAYC,MAAZ,EAAoB;AACnBF,YAAOC,GAAP,IAAcC,OAAOD,GAAP,CAAd;AACA;AACD;AACD,UAAOD,MAAP;AACA,G;;SASMM,e,4BAAgBC,I,EAAMC,O,EAAS;AACrC,OAAIC,QAAQD,WAAWE,MAAvB;AACA,OAAIC,QAAQJ,KAAKK,KAAL,CAAW,GAAX,CAAZ;AACA,UAAOD,MAAME,MAAN,CAAa,UAACC,IAAD,EAAOb,GAAP;AAAA,WAAea,KAAKb,GAAL,CAAf;AAAA,IAAb,EAAuCQ,KAAvC,CAAP;AACA,G;;SASMM,G,gBAAIC,G,EAAKC,E,EAAI;AACnB,OAAIC,YAAY,EAAhB;AACA,OAAIC,OAAOC,OAAOD,IAAP,CAAYH,GAAZ,CAAX;AACA,QAAK,IAAIb,IAAI,CAAb,EAAgBA,IAAIgB,KAAKd,MAAzB,EAAiCF,GAAjC,EAAsC;AACrCe,cAAUC,KAAKhB,CAAL,CAAV,IAAqBc,GAAGE,KAAKhB,CAAL,CAAH,EAAYa,IAAIG,KAAKhB,CAAL,CAAJ,CAAZ,CAArB;AACA;AACD,UAAOe,SAAP;AACA,G;;SAOMG,Y,yBAAaC,I,EAAMC,I,EAAM;AAC/B,OAAID,SAASC,IAAb,EAAmB;AAClB,WAAO,IAAP;AACA;;AAED,OAAIC,QAAQJ,OAAOD,IAAP,CAAYG,IAAZ,CAAZ;AACA,OAAIG,QAAQL,OAAOD,IAAP,CAAYI,IAAZ,CAAZ;AACA,OAAIC,MAAMnB,MAAN,KAAiBoB,MAAMpB,MAA3B,EAAmC;AAClC,WAAO,KAAP;AACA;;AAED,QAAK,IAAIF,IAAI,CAAb,EAAgBA,IAAIqB,MAAMnB,MAA1B,EAAkCF,GAAlC,EAAuC;AACtC,QAAImB,KAAKE,MAAMrB,CAAN,CAAL,MAAmBoB,KAAKC,MAAMrB,CAAN,CAAL,CAAvB,EAAuC;AACtC,YAAO,KAAP;AACA;AACD;AACD,UAAO,IAAP;AACA,G;;;;;mBAGaL,M","file":"node_modules/metal/src/object/object.js","sourcesContent":["'use strict';\n\nclass object {\n\t/**\n\t * Copies all the members of a source object to a target object.\n\t * @param {Object} target Target object.\n\t * @param {...Object} var_args The objects from which values will be copied.\n\t * @return {Object} Returns the target object reference.\n\t */\n\tstatic mixin(target) {\n\t\tvar key, source;\n\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\tsource = arguments[i];\n\t\t\tfor (key in source) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Returns an object based on its fully qualified external name.\n\t * @param {string} name The fully qualified name.\n\t * @param {object=} opt_obj The object within which to look; default is\n\t *     <code>window</code>.\n\t * @return {?} The value (object or primitive) or, if not found, undefined.\n\t */\n\tstatic getObjectByName(name, opt_obj) {\n\t\tvar scope = opt_obj || window;\n\t\tvar parts = name.split('.');\n\t\treturn parts.reduce((part, key) => part[key], scope);\n\t}\n\n\t/**\n\t * Returns a new object with the same keys as the given one, but with\n\t * their values set to the return values of the specified function.\n\t * @param {!Object} obj\n\t * @param {!function(string, *)} fn\n\t * @return {!Object}\n\t */\n\tstatic map(obj, fn) {\n\t\tvar mappedObj = {};\n\t\tvar keys = Object.keys(obj);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tmappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);\n\t\t}\n\t\treturn mappedObj;\n\t}\n\n\t/**\n\t * Checks if the two given objects are equal. This is done via a shallow\n\t * check, including only the keys directly contained by the 2 objects.\n\t * @return {boolean}\n\t */\n\tstatic shallowEqual(obj1, obj2) {\n\t\tif (obj1 === obj2) {\n\t\t\treturn true;\n\t\t}\n\n\t\tvar keys1 = Object.keys(obj1);\n\t\tvar keys2 = Object.keys(obj2);\n\t\tif (keys1.length !== keys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (var i = 0; i < keys1.length; i++) {\n\t\t\tif (obj1[keys1[i]] !== obj2[keys1[i]]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport default object;\n"],"sourceRoot":"/source/"}