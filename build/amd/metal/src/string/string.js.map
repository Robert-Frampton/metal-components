{"version":3,"sources":["string.js"],"names":["string","collapseBreakingSpaces","str","replace","escapeRegex","String","getRandomString","x","Math","floor","random","toString","abs","Date","now","hashCode","val","hash","i","len","length","charCodeAt","replaceInterval","start","end","value","substring"],"mappings":";AAAA;;;;;;;;;;;;KAEMA,M;;;;;SAQEC,sB,mCAAuBC,G,EAAK;AAClC,UAAOA,IAAIC,OAAJ,CAAY,aAAZ,EAA2B,GAA3B,EAAgCA,OAAhC,CAAwC,0BAAxC,EAAoE,EAApE,CAAP;AACA,G;;SAQMC,W,wBAAYF,G,EAAK;AACvB,UAAOG,OAAOH,GAAP,EACLC,OADK,CACG,+BADH,EACoC,MADpC,EAELA,OAFK,CAEG,OAFH,EAEY,OAFZ,CAAP;AAGA,G;;SAMMG,e,8BAAkB;AACxB,OAAIC,IAAI,UAAR;AACA,UAAOC,KAAKC,KAAL,CAAWD,KAAKE,MAAL,KAAgBH,CAA3B,EAA8BI,QAA9B,CAAuC,EAAvC,IACNH,KAAKI,GAAL,CAASJ,KAAKC,KAAL,CAAWD,KAAKE,MAAL,KAAgBH,CAA3B,IAAgCM,KAAKC,GAAL,EAAzC,EAAqDH,QAArD,CAA8D,EAA9D,CADD;AAEA,G;;SAWMI,Q,qBAASC,G,EAAK;AACpB,OAAIC,OAAO,CAAX;AACA,QAAK,IAAIC,IAAI,CAAR,EAAWC,MAAMH,IAAII,MAA1B,EAAkCF,IAAIC,GAAtC,EAA2CD,GAA3C,EAAgD;AAC/CD,WAAO,KAAKA,IAAL,GAAYD,IAAIK,UAAJ,CAAeH,CAAf,CAAnB;AACAD,YAAQ,WAAR;AACA;AACD,UAAOA,IAAP;AACA,G;;SAWMK,e,4BAAgBpB,G,EAAKqB,K,EAAOC,G,EAAKC,K,EAAO;AAC9C,UAAOvB,IAAIwB,SAAJ,CAAc,CAAd,EAAiBH,KAAjB,IAA0BE,KAA1B,GAAkCvB,IAAIwB,SAAJ,CAAcF,GAAd,CAAzC;AACA,G;;;;;mBAGaxB,M","file":"node_modules/metal/src/string/string.js","sourcesContent":["'use strict';\n\nclass string {\n\t/**\n\t * Removes the breaking spaces from the left and right of the string and\n\t * collapses the sequences of breaking spaces in the middle into single spaces.\n\t * The original and the result strings render the same way in HTML.\n\t * @param {string} str A string in which to collapse spaces.\n\t * @return {string} Copy of the string with normalized breaking spaces.\n\t */\n\tstatic collapseBreakingSpaces(str) {\n\t\treturn str.replace(/[\\t\\r\\n ]+/g, ' ').replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, '');\n\t}\n\n\t/**\n\t* Escapes characters in the string that are not safe to use in a RegExp.\n\t* @param {*} str The string to escape. If not a string, it will be casted\n\t*     to one.\n\t* @return {string} A RegExp safe, escaped copy of {@code s}.\n\t*/\n\tstatic escapeRegex(str) {\n\t\treturn String(str)\n\t\t\t.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1')\n\t\t\t.replace(/\\x08/g, '\\\\x08');\n\t}\n\n\t/**\n\t* Returns a string with at least 64-bits of randomness.\n\t* @return {string} A random string, e.g. sn1s7vb4gcic.\n\t*/\n\tstatic getRandomString() {\n\t\tvar x = 2147483648;\n\t\treturn Math.floor(Math.random() * x).toString(36) +\n\t\t\tMath.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);\n\t}\n\n\t/**\n\t * Calculates the hashcode for a string. The hashcode value is computed by\n\t * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice\n\t * property of using 31 prime is that the multiplication can be replaced by\n\t * a shift and a subtraction for better performance: 31*i == (i<<5)-i.\n\t * Modern VMs do this sort of optimization automatically.\n\t * @param {String} val Target string.\n\t * @return {Number} Returns the string hashcode.\n\t */\n\tstatic hashCode(val) {\n\t\tvar hash = 0;\n\t\tfor (var i = 0, len = val.length; i < len; i++) {\n\t\t\thash = 31 * hash + val.charCodeAt(i);\n\t\t\thash %= 0x100000000;\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**\n\t * Replaces interval into the string with specified value, e.g.\n\t * `replaceInterval(\"abcde\", 1, 4, \"\")` returns \"ae\".\n\t * @param {string} str The input string.\n\t * @param {Number} start Start interval position to be replaced.\n\t * @param {Number} end End interval position to be replaced.\n\t * @param {string} value The value that replaces the specified interval.\n\t * @return {string}\n\t */\n\tstatic replaceInterval(str, start, end, value) {\n\t\treturn str.substring(0, start) + value + str.substring(end);\n\t}\n}\n\nexport default string;\n"],"sourceRoot":"/source/"}