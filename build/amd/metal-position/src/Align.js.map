{"version":3,"sources":["Align.js"],"names":["Align","align","element","alignElement","position","suggestion","suggestAlignBestRegion","bestRegion","region","computedStyle","window","getComputedStyle","getPropertyValue","top","pageYOffset","left","pageXOffset","offsetParent","getOffsetTop","getOffsetLeft","style","getAlignBestRegion","getAlignRegion","r1","getRegion","r2","TopCenter","height","width","RightCenter","BottomCenter","bottom","LeftCenter","TopRight","right","BottomRight","BottomLeft","TopLeft","isValidPosition","val","bestArea","bestPosition","tryPosition","tryRegion","viewportRegion","i","intersectRegion","visibleRegion","intersection","area","insideViewport","Top","Right","Bottom","Left"],"mappings":"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","file":"node_modules/metal-position/src/Align.js","sourcesContent":["'use strict';\n\nimport Position from './Position';\n\n/**\n * Align utility. Computes region or best region to align an element with\n * another. Regions are relative to viewport, make sure to use element with\n * position fixed, or position absolute when the element first positioned\n * parent is the body element.\n */\nclass Align {\n\n\t/**\n\t * Aligns the element with the best region around alignElement. The best\n\t * region is defined by clockwise rotation starting from the specified\n\t * `position`. The element is always aligned in the middle of alignElement\n\t * axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {string} The final chosen position for the aligned element.\n\t * @static\n\t */\n\tstatic align(element, alignElement, position) {\n\t\tvar suggestion = this.suggestAlignBestRegion(element, alignElement, position);\n\t\tvar bestRegion = suggestion.region;\n\n\t\tvar computedStyle = window.getComputedStyle(element, null);\n\t\tif (computedStyle.getPropertyValue('position') !== 'fixed') {\n\t\t\tbestRegion.top += window.pageYOffset;\n\t\t\tbestRegion.left += window.pageXOffset;\n\n\t\t\tvar offsetParent = element;\n\t\t\twhile ((offsetParent = offsetParent.offsetParent)) {\n\t\t\t\tbestRegion.top -= Position.getOffsetTop(offsetParent);\n\t\t\t\tbestRegion.left -= Position.getOffsetLeft(offsetParent);\n\t\t\t}\n\t\t}\n\n\t\telement.style.top = bestRegion.top + 'px';\n\t\telement.style.left = bestRegion.left + 'px';\n\t\treturn suggestion.position;\n\t}\n\n\t/**\n\t * Returns the best region to align element with alignElement. This is similar\n\t * to `Align.suggestAlignBestRegion`, but it only returns the region information,\n\t * while `Align.suggestAlignBestRegion` also returns the chosen position.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {DOMRect} Best region to align element.\n\t * @static\n\t */\n\tstatic getAlignBestRegion(element, alignElement, position) {\n\t\treturn Align.suggestAlignBestRegion(element, alignElement, position).region;\n\t}\n\n\t/**\n\t * Returns the region to align element with alignElement. The element is\n\t * always aligned in the middle of alignElement axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The position to align. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {DOMRect} Region to align element.\n\t * @static\n\t */\n\tstatic getAlignRegion(element, alignElement, position) {\n\t\tvar r1 = Position.getRegion(alignElement);\n\t\tvar r2 = Position.getRegion(element);\n\t\tvar top = 0;\n\t\tvar left = 0;\n\n\t\tswitch (position) {\n\t\t\tcase Align.TopCenter:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.left + r1.width / 2 - r2.width / 2;\n\t\t\t\tbreak;\n\t\t\tcase Align.RightCenter:\n\t\t\t\ttop = r1.top + r1.height / 2 - r2.height / 2;\n\t\t\t\tleft = r1.left + r1.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomCenter:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.left + r1.width / 2 - r2.width / 2;\n\t\t\t\tbreak;\n\t\t\tcase Align.LeftCenter:\n\t\t\t\ttop = r1.top + r1.height / 2 - r2.height / 2;\n\t\t\t\tleft = r1.left - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.TopRight:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.right - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomRight:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.right - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomLeft:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.left;\n\t\t\t\tbreak;\n\t\t\tcase Align.TopLeft:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.left;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn {\n\t\t\tbottom: top + r2.height,\n\t\t\theight: r2.height,\n\t\t\tleft: left,\n\t\t\tright: left + r2.width,\n\t\t\ttop: top,\n\t\t\twidth: r2.width\n\t\t};\n\t}\n\n\t/**\n\t * Checks if specified value is a valid position. Options `Align.Top`,\n\t *     `Align.Right`, `Align.Bottom`, `Align.Left`.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} val\n\t * @return {boolean} Returns true if value is a valid position.\n\t * @static\n\t */\n\tstatic isValidPosition(val) {\n\t\treturn 0 <= val && val <= 8;\n\t}\n\n\t/**\n\t * Looks for the best region for aligning the given element. The best\n\t * region is defined by clockwise rotation starting from the specified\n\t * `position`. The element is always aligned in the middle of alignElement\n\t * axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {{position: string, region: DOMRect}} Best region to align element.\n\t * @static\n\t */\n\tstatic suggestAlignBestRegion(element, alignElement, position) {\n\t\tvar bestArea = 0;\n\t\tvar bestPosition = position;\n\t\tvar bestRegion = this.getAlignRegion(element, alignElement, bestPosition);\n\t\tvar tryPosition = bestPosition;\n\t\tvar tryRegion = bestRegion;\n\t\tvar viewportRegion = Position.getRegion(window);\n\n\t\tfor (var i = 0; i < 8;) {\n\t\t\tif (Position.intersectRegion(viewportRegion, tryRegion)) {\n\t\t\t\tvar visibleRegion = Position.intersection(viewportRegion, tryRegion);\n\t\t\t\tvar area = visibleRegion.width * visibleRegion.height;\n\t\t\t\tif (area > bestArea) {\n\t\t\t\t\tbestArea = area;\n\t\t\t\t\tbestRegion = tryRegion;\n\t\t\t\t\tbestPosition = tryPosition;\n\t\t\t\t}\n\t\t\t\tif (Position.insideViewport(tryRegion)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttryPosition = (position + (++i)) % 8;\n\t\t\ttryRegion = this.getAlignRegion(element, alignElement, tryPosition);\n\t\t}\n\n\t\treturn {\n\t\t\tposition: bestPosition,\n\t\t\tregion: bestRegion\n\t\t};\n\t}\n}\n\n/**\n * Constants that represent the supported positions for `Align`.\n * @type {number}\n * @static\n */\n\nAlign.TopCenter = 0;\nAlign.TopRight = 1;\nAlign.RightCenter = 2;\nAlign.BottomRight = 3;\nAlign.BottomCenter = 4;\nAlign.BottomLeft = 5;\nAlign.LeftCenter = 6;\nAlign.TopLeft = 7;\n\n/**\n * Aliases for position constants.\n * @type {number}\n * @static\n */\nAlign.Top = Align.TopCenter;\nAlign.Right = Align.RightCenter;\nAlign.Bottom = Align.BottomCenter;\nAlign.Left = Align.LeftCenter;\n\nexport default Align;\n"],"sourceRoot":"/source/"}