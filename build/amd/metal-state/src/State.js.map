{"version":3,"sources":["State.js"],"names":["State","opt_config","opt_obj","opt_context","opt_commonOpts","commonOpts_","context_","keysBlacklist_","obj_","scheduledBatchData_","stateInfo_","setShouldUseFacade","mergeInvalidKeys_","addToStateFromStaticHint_","addKeyToState","name","config","initialValue","buildKeyInfo_","arguments","length","Object","defineProperty","buildKeyPropertyDef_","validateInitialValue_","assertGivenIfRequired_","addToState","configsOrName","opt_initialValuesOrConfig","opt_contextOrInitialValue","isString","initialValues","names","keys","props","i","hasOwnProperty","defineProperties","ctor","constructor","defineContext","merged","mergeStateStatic","prototype","STATE_MERGED","info","required","value","state","KeyStates","INITIALIZED","get","isDefAndNotNull","console","error","assertValidStateKeyName_","INVALID_KEYS_MERGED","Error","hasInitialValue","mixin","UNINITIALIZED","stateObj","configurable","enumerable","getStateKeyValue_","set","val","setStateKeyValue_","callFunction_","fn","args","apply","isFunction","callSetter_","currentValue","setter","callValidator_","validator","validatorReturn","canSetState","writeOnce","written","disposeInternal","emitBatchEvent_","isDisposed","data","emit","getState","opt_names","getStateKeys","getStateKeyConfig","warnIfDisposed_","initStateKey_","hasBeenSet","hasInitialValue_","hasStateKey","key","informChange_","prevVal","shouldInformChange_","newVal","scheduleBatchEvent_","INITIALIZING","setInitialValue_","setDefaultValue","mergeState","values","concat","reverse","mergeSuperClassesProperty","flatten","reduce","removeStateKey","changeData","nextTick","changes","undefined","valueFn","setKeysBlacklist_","blacklist","setState","opt_callback","forEach","once","validateKeyValue_","isObject","disposed","warn","INVALID_KEYS"],"mappings":"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","file":"node_modules/metal-state/src/State.js","sourcesContent":["'use strict';\n\nimport { array, async, core, object } from 'metal';\nimport { EventEmitter } from 'metal-events';\n\n/**\n * State adds support for having object properties that can be watched for\n * changes, as well as configured with validators, setters and other options.\n * See the `addToState` method for a complete list of available configuration\n * options for each state key.\n * @extends {EventEmitter}\n */\nclass State extends EventEmitter {\n\t/**\n\t * Constructor function for `State`.\n\t * @param {Object=} opt_config Optional config object with initial values to\n\t *     set state properties to.\n\t * @param {Object=} opt_obj Optional object that should hold the state\n\t *     properties. If none is given, they will be added directly to `this`\n\t *     instead.\n\t * @param {Object=} opt_context Optional context to call functions (like\n\t *     validators and setters) on. Defaults to `this`.\n\t * @param {Object=} opt_commonOpts Optional common option values to be used\n\t *     by all this instance's state properties.\n\t */\n\tconstructor(opt_config, opt_obj, opt_context, opt_commonOpts) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Common option values to be used by all this instance's state properties.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.commonOpts_ = opt_commonOpts;\n\n\t\t/**\n\t\t * Context to call functions (like validators and setters) on.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.context_ = opt_context || this;\n\n\t\t/**\n\t\t * Map of keys that can not be used as state keys.\n\t\t * @type {!Object<string, boolean>}\n\t\t * @protected\n\t\t */\n\t\tthis.keysBlacklist_ = {};\n\n\t\t/**\n\t\t * Object that should hold the state properties.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.obj_ = opt_obj || this;\n\n\t\t/**\n\t\t * Object with information about the batch event that is currently\n\t\t * scheduled, or null if none is.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.scheduledBatchData_ = null;\n\n\t\t/**\n\t\t * Object that contains information about all this instance's state keys.\n\t\t * @type {!Object<string, !Object>}\n\t\t * @protected\n\t\t */\n\t\tthis.stateInfo_ = {};\n\n\t\tthis.setShouldUseFacade(true);\n\t\tthis.mergeInvalidKeys_();\n\t\tthis.addToStateFromStaticHint_(opt_config);\n\t}\n\n\t/**\n\t * Adds the given key to the state.\n\t * @param {string} name The name of the new state key.\n\t * @param {Object.<string, *>=} config The configuration object for the new\n\t *     key. See `addToState` for supported settings.\n\t * @param {*} initialValue The initial value of the new key.\n\t */\n\taddKeyToState(name, config, initialValue) {\n\t\tthis.buildKeyInfo_(name, config, initialValue, arguments.length > 2);\n\t\tObject.defineProperty(\n\t\t\tthis.obj_,\n\t\t\tname,\n\t\t\tthis.buildKeyPropertyDef_(name)\n\t\t);\n\t\tthis.validateInitialValue_(name);\n\t\tthis.assertGivenIfRequired_(name);\n\t}\n\n\t/**\n\t * Adds the given key(s) to the state, together with its(their) configs.\n\t * Config objects support the given settings:\n\t *     required - When set to `true`, causes errors to be printed (via\n\t *     `console.error`) if no value is given for the property.\n\t *\n\t *     setter - Function for normalizing state key values. It receives the new\n\t *     value that was set, and returns the value that should be stored.\n\t *\n\t *     validator - Function that validates state key values. When it returns\n\t *     false, the new value is ignored. When it returns an instance of Error,\n\t *     it will emit the error to the console.\n\t *\n\t *     value - The default value for the state key. Note that setting this to\n\t *     an object will cause all class instances to use the same reference to\n\t *     the object. To have each instance use a different reference for objects,\n\t *     use the `valueFn` option instead.\n\t *\n\t *     valueFn - A function that returns the default value for a state key.\n\t *\n\t *     writeOnce - Ignores writes to the state key after it's been first\n\t *     written to. That is, allows writes only when setting the value for the\n\t *     first time.\n\t * @param {!Object.<string, !Object>|string} configsOrName An object that maps\n\t *     configuration options for keys to be added to the state or the name of\n\t *     a single key to be added.\n\t * @param {Object.<string, *>=} opt_initialValuesOrConfig An object that maps\n\t *     state keys to their initial values. These values have higher precedence\n\t *     than the default values specified in the configurations. If a single\n\t *     key name was passed as the first param instead though, then this should\n\t *     be the configuration object for that key.\n\t * @param {boolean|Object|*=} opt_contextOrInitialValue If the first\n\t *     param passed to this method was a config object, this should be the\n\t *     context where the added state keys will be defined (defaults to `this`),\n\t *     or false if they shouldn't be defined at all. If the first param was a\n\t *     single key name though, this should be its initial value.\n\t */\n\taddToState(configsOrName, opt_initialValuesOrConfig, opt_contextOrInitialValue) {\n\t\tif (core.isString(configsOrName)) {\n\t\t\treturn this.addKeyToState(...arguments);\n\t\t}\n\n\t\tvar initialValues = opt_initialValuesOrConfig || {};\n\t\tvar names = Object.keys(configsOrName);\n\n\t\tvar props = {};\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tvar name = names[i];\n\t\t\tthis.buildKeyInfo_(\n\t\t\t\tname,\n\t\t\t\tconfigsOrName[name],\n\t\t\t\tinitialValues[name],\n\t\t\t\tinitialValues.hasOwnProperty(name)\n\t\t\t);\n\t\t\tprops[name] = this.buildKeyPropertyDef_(name, opt_contextOrInitialValue);\n\t\t\tthis.assertGivenIfRequired_(name);\n\t\t}\n\n\t\tif (opt_contextOrInitialValue !== false) {\n\t\t\tObject.defineProperties(\n\t\t\t\topt_contextOrInitialValue || this.obj_,\n\t\t\t\tprops\n\t\t\t);\n\t\t}\n\n\t\t// Validate initial values after all properties have been defined, otherwise\n\t\t// it won't be possible to access those properties within validators.\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tthis.validateInitialValue_(names[i]);\n\t\t}\n\t}\n\n\t/**\n\t * Adds state keys from super classes static hint `MyClass.STATE = {};`.\n\t * @param {Object.<string, !Object>=} opt_config An object that maps all the\n\t *     configurations for state keys.\n\t * @protected\n\t */\n\taddToStateFromStaticHint_(opt_config) {\n\t\tvar ctor = this.constructor;\n\t\tvar defineContext;\n\t\tvar merged = State.mergeStateStatic(ctor);\n\t\tif (this.obj_ === this) {\n\t\t\tdefineContext = merged ? ctor.prototype : false;\n\t\t}\n\t\tthis.addToState(ctor.STATE_MERGED, opt_config, defineContext);\n\t}\n\n\t/**\n\t * Logs an error if the given property is required but wasn't given.\n\t * @param {string} name\n\t * @protected\n\t */\n\tassertGivenIfRequired_(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\tif (info.config.required) {\n\t\t\tvar value = info.state === State.KeyStates.INITIALIZED ?\n\t\t\t\tthis.get(name) :\n\t\t\t\tinfo.initialValue;\n\t\t\tif (!core.isDefAndNotNull(value)) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'The property called \"' + name + '\" is required but didn\\n\\'t ' +\n\t\t\t\t\t'receive a value.'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the given name is a valid state key name. If it's not, an error\n\t * will be thrown.\n\t * @param {string} name The name to be validated.\n\t * @throws {Error}\n\t * @protected\n\t */\n\tassertValidStateKeyName_(name) {\n\t\tif (this.constructor.INVALID_KEYS_MERGED[name] || this.keysBlacklist_[name]) {\n\t\t\tthrow new Error('It\\'s not allowed to create a state key with the name \"' + name + '\".');\n\t\t}\n\t}\n\n\t/**\n\t * Builds the info object for the specified state key.\n\t * @param {string} name The name of the key.\n\t * @param {Object} config The config object for the key.\n\t * @param {*} initialValue The initial value of the key.\n\t * @param {boolean} hasInitialValue Flag indicating if an initial value was\n\t *     given or not (important since `initialValue` can also be `undefined`).\n\t * @protected\n\t */\n\tbuildKeyInfo_(name, config, initialValue, hasInitialValue) {\n\t\tthis.assertValidStateKeyName_(name);\n\t\tconfig = (config && config.config) ? config.config : (config || {});\n\t\tif (this.commonOpts_) {\n\t\t\tconfig = object.mixin({}, config, this.commonOpts_);\n\t\t}\n\t\tthis.stateInfo_[name] = {\n\t\t\tconfig,\n\t\t\tstate: State.KeyStates.UNINITIALIZED\n\t\t};\n\t\tif (hasInitialValue) {\n\t\t\tthis.stateInfo_[name].initialValue = initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Builds the property definition object for the specified state key.\n\t * @param {string} name The name of the key.\n\t * @param {Object=} opt_context The object where the property will be added.\n\t * @return {!Object}\n\t * @protected\n\t */\n\tbuildKeyPropertyDef_(name, opt_context) {\n\t\tvar stateObj = opt_context === this.constructor.prototype ? null : this;\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn (stateObj || this).getStateKeyValue_(name);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\t(stateObj || this).setStateKeyValue_(name, val);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Calls the requested function, running the appropriate code for when it's\n\t * passed as an actual function object or just the function's name.\n\t * @param {!Function|string} fn Function, or name of the function to run.\n\t * @param {!Array} An optional array of parameters to be passed to the\n\t *   function that will be called.\n\t * @return {*} The return value of the called function.\n\t * @protected\n\t */\n\tcallFunction_(fn, args) {\n\t\tif (core.isString(fn)) {\n\t\t\treturn this.context_[fn].apply(this.context_, args);\n\t\t} else if (core.isFunction(fn)) {\n\t\t\treturn fn.apply(this.context_, args);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the state key's setter, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be set.\n\t * @param {*} currentValue The current value.\n\t * @return {*} The final value to be set.\n\t * @protected\n\t */\n\tcallSetter_(name, value, currentValue) {\n\t\tvar info = this.stateInfo_[name];\n\t\tvar config = info.config;\n\t\tif (config.setter) {\n\t\t\tvalue = this.callFunction_(config.setter, [value, currentValue]);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Calls the state key's validator, if there is one. Emits console\n\t * warning if validator returns a string.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tcallValidator_(name, value) {\n\t\tvar info = this.stateInfo_[name];\n\t\tvar config = info.config;\n\t\tif (config.validator) {\n\t\t\tvar validatorReturn = this.callFunction_(\n\t\t\t\tconfig.validator,\n\t\t\t\t[value, name, this.context_]\n\t\t\t);\n\n\t\t\tif (validatorReturn instanceof Error) {\n\t\t\t\tconsole.error(`Warning: ${validatorReturn}`);\n\t\t\t}\n\t\t\treturn validatorReturn;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the it's allowed to write on the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\tcanSetState(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\treturn !info.config.writeOnce || !info.written;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tthis.stateInfo_ = null;\n\t\tthis.scheduledBatchData_ = null;\n\t}\n\n\t/**\n\t * Emits the state change batch event.\n\t * @protected\n\t */\n\temitBatchEvent_() {\n\t\tif (!this.isDisposed()) {\n\t\t\tvar data = this.scheduledBatchData_;\n\t\t\tthis.scheduledBatchData_ = null;\n\t\t\tthis.emit('stateChanged', data);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value of the requested state key.\n\t * Note: this can and should be accomplished by accessing the value as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this.obj_[name];\n\t}\n\n\t/**\n\t * Returns an object that maps state keys to their values.\n\t * @param {Array<string>=} opt_names A list of names of the keys that should\n\t *   be returned. If none is given, the whole state will be returned.\n\t * @return {Object.<string, *>}\n\t */\n\tgetState(opt_names) {\n\t\tvar state = {};\n\t\tvar names = opt_names || this.getStateKeys();\n\n\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\tstate[names[i]] = this.get(names[i]);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Gets the config object for the requested state key.\n\t * @param {string} name The key's name.\n\t * @return {Object}\n\t * @protected\n\t */\n\tgetStateKeyConfig(name) {\n\t\treturn (this.stateInfo_[name] || {}).config;\n\t}\n\n\t/**\n\t * Returns an array with all state keys.\n\t * @return {!Array.<string>}\n\t */\n\tgetStateKeys() {\n\t\treturn this.stateInfo_ ? Object.keys(this.stateInfo_) : [];\n\t}\n\n\t/**\n\t * Gets the value of the specified state key. This is passed as that key's\n\t * getter to the `Object.defineProperty` call inside the `addKeyToState` method.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tgetStateKeyValue_(name) {\n\t\tif (!this.warnIfDisposed_(name)) {\n\t\t\tthis.initStateKey_(name);\n\t\t\treturn this.stateInfo_[name].value;\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the value of the state key with the given name has already been\n\t * set. Note that this doesn't run the key's getter.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\thasBeenSet(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\treturn info.state === State.KeyStates.INITIALIZED ||\n\t\t\tthis.hasInitialValue_(name);\n\t}\n\n\t/**\n\t * Checks if an initial value was given to the specified state property.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t * @protected\n\t */\n\thasInitialValue_(name) {\n\t\treturn this.stateInfo_[name].hasOwnProperty('initialValue');\n\t}\n\n\t/**\n\t * Checks if the given key is present in this instance's state.\n\t * @param {string} key\n\t * @return {boolean}\n\t */\n\thasStateKey(key) {\n\t\tif (!this.warnIfDisposed_(key)) {\n\t\t\treturn !!this.stateInfo_[key];\n\t\t}\n\t}\n\n\t/**\n\t * Informs of changes to a state key's value through an event. Won't trigger\n\t * the event if the value hasn't changed or if it's being initialized.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @protected\n\t */\n\tinformChange_(name, prevVal) {\n\t\tif (this.shouldInformChange_(name, prevVal)) {\n\t\t\tvar data = {\n\t\t\t\tkey: name,\n\t\t\t\tnewVal: this.get(name),\n\t\t\t\tprevVal: prevVal\n\t\t\t};\n\t\t\tthis.emit(name + 'Changed', data);\n\t\t\tthis.emit('stateKeyChanged', data);\n\t\t\tthis.scheduleBatchEvent_(data);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the specified state key, giving it a first value.\n\t * @param {string} name The name of the key.\n\t * @protected\n\t */\n\tinitStateKey_(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\tif (info.state !== State.KeyStates.UNINITIALIZED) {\n\t\t\treturn;\n\t\t}\n\n\t\tinfo.state = State.KeyStates.INITIALIZING;\n\t\tthis.setInitialValue_(name);\n\t\tif (!info.written) {\n\t\t\tthis.setDefaultValue(name);\n\t\t}\n\t\tinfo.state = State.KeyStates.INITIALIZED;\n\t}\n\n\t/**\n\t * Merges an array of values for the STATE property into a single object.\n\t * @param {!Array} values The values to be merged.\n\t * @return {!Object} The merged value.\n\t * @static\n\t */\n\tstatic mergeState(values) {\n\t\treturn object.mixin.apply(null, [{}].concat(values.reverse()));\n\t}\n\n\t/**\n\t * Merges the STATE static variable for the given constructor function.\n\t * @param  {!Function} ctor Constructor function.\n\t * @return {boolean} Returns true if merge happens, false otherwise.\n\t * @static\n\t */\n\tstatic mergeStateStatic(ctor) {\n\t\treturn core.mergeSuperClassesProperty(ctor, 'STATE', State.mergeState);\n\t}\n\n\t/**\n\t * Merges the values of the `INVALID_KEYS` static for the whole hierarchy of\n\t * the current instance.\n\t * @protected\n\t */\n\tmergeInvalidKeys_() {\n\t\tcore.mergeSuperClassesProperty(this.constructor, 'INVALID_KEYS', function(values) {\n\t\t\treturn array.flatten(values).reduce(function(merged, val) {\n\t\t\t\tif (val) {\n\t\t\t\t\tmerged[val] = true;\n\t\t\t\t}\n\t\t\t\treturn merged;\n\t\t\t}, {});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the requested state key.\n\t * @param {string} name The name of the key.\n\t */\n\tremoveStateKey(name) {\n\t\tthis.stateInfo_[name] = null;\n\t\tdelete this.obj_[name];\n\t}\n\n\t/**\n\t * Schedules a state change batch event to be emitted asynchronously.\n\t * @param {!Object} changeData Information about a state key's update.\n\t * @protected\n\t */\n\tscheduleBatchEvent_(changeData) {\n\t\tif (!this.scheduledBatchData_) {\n\t\t\tasync.nextTick(this.emitBatchEvent_, this);\n\t\t\tthis.scheduledBatchData_ = {\n\t\t\t\tchanges: {}\n\t\t\t};\n\t\t}\n\n\t\tvar name = changeData.key;\n\t\tvar changes = this.scheduledBatchData_.changes;\n\t\tif (changes[name]) {\n\t\t\tchanges[name].newVal = changeData.newVal;\n\t\t} else {\n\t\t\tchanges[name] = changeData;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the requested state key.\n\t * Note: this can and should be accomplished by setting the state key as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @param {*} value\n\t * @return {*}\n\t */\n\tset(name, value) {\n\t\tif (this.hasStateKey(name)) {\n\t\t\tthis.obj_[name] = value;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default value of the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t */\n\tsetDefaultValue(name) {\n\t\tvar config = this.stateInfo_[name].config;\n\n\t\tif (config.value !== undefined) {\n\t\t\tthis.set(name, config.value);\n\t\t} else {\n\t\t\tthis.set(name, this.callFunction_(config.valueFn));\n\t\t}\n\t}\n\n\t/**\n\t * Sets the initial value of the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tsetInitialValue_(name) {\n\t\tif (this.hasInitialValue_(name)) {\n\t\t\tvar info = this.stateInfo_[name];\n\t\t\tthis.set(name, info.initialValue);\n\t\t\tinfo.initialValue = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Sets a map of keys that are not valid state keys.\n\t * @param {!Object<string, boolean>}\n\t */\n\tsetKeysBlacklist_(blacklist) {\n\t\tthis.keysBlacklist_ = blacklist;\n\t}\n\n\t/**\n\t * Sets the value of all the specified state keys.\n\t * @param {!Object.<string,*>} values A map of state keys to the values they\n\t *   should be set to.\n\t * @param {function()=} opt_callback An optional function that will be run\n\t *   after the next batched update is triggered.\n\t */\n\tsetState(values, opt_callback) {\n\t\tObject.keys(values).forEach(name => this.set(name, values[name]));\n\t\tif (opt_callback && this.scheduledBatchData_) {\n\t\t\tthis.once('stateChanged', opt_callback);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the specified state key. This is passed as that key's\n\t * setter to the `Object.defineProperty` call inside the `addKeyToState`\n\t * method.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The new value of the key.\n\t * @protected\n\t */\n\tsetStateKeyValue_(name, value) {\n\t\tif (this.warnIfDisposed_(name) ||\n\t\t\t!this.canSetState(name) ||\n\t\t\t!this.validateKeyValue_(name, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar info = this.stateInfo_[name];\n\t\tif (!this.hasInitialValue_(name) && info.state === State.KeyStates.UNINITIALIZED) {\n\t\t\tinfo.state = State.KeyStates.INITIALIZED;\n\t\t}\n\n\t\tvar prevVal = this.get(name);\n\t\tinfo.value = this.callSetter_(name, value, prevVal);\n\t\tthis.assertGivenIfRequired_(name);\n\t\tinfo.written = true;\n\t\tthis.informChange_(name, prevVal);\n\t}\n\n\t/**\n\t * Checks if we should inform about a state update. Updates are ignored during\n\t * state initialization. Otherwise, updates to primitive values are only\n\t * informed when the new value is different from the previous one. Updates to\n\t * objects (which includes functions and arrays) are always informed outside\n\t * initialization though, since we can't be sure if all of the internal data\n\t * has stayed the same.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldInformChange_(name, prevVal) {\n\t\tvar info = this.stateInfo_[name];\n\t\treturn (info.state === State.KeyStates.INITIALIZED) &&\n\t\t\t(core.isObject(prevVal) || prevVal !== this.get(name));\n\t}\n\n\t/**\n\t * Validates the initial value for the state property with the given name.\n\t * @param {string} name\n\t * @protected\n\t */\n\tvalidateInitialValue_(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\tif (this.hasInitialValue_(name) && !this.callValidator_(name, info.initialValue)) {\n\t\t\tdelete info.initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Validates the state key's value, which includes calling the validator\n\t * defined in the key's configuration object, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tvalidateKeyValue_(name, value) {\n\t\tvar info = this.stateInfo_[name];\n\n\t\treturn info.state === State.KeyStates.INITIALIZING ||\n\t\t\tthis.callValidator_(name, value);\n\t}\n\n\t/**\n\t * Warns if this instance has already been disposed.\n\t * @param {string} name Name of the property to be accessed if not disposed.\n\t * @return {boolean} True if disposed, or false otherwise.\n\t * @protected\n\t */\n\twarnIfDisposed_(name) {\n\t\tconst disposed = this.isDisposed();\n\t\tif (disposed) {\n\t\t\tconsole.warn(\n\t\t\t\t`Error. Trying to access property \"${name}\" on disposed instance`\n\t\t\t);\n\t\t}\n\t\treturn disposed;\n\t}\n}\n\n/**\n * A list with state key names that will automatically be rejected as invalid.\n * Subclasses can define their own invalid keys by setting this static on their\n * constructors, which will be merged together and handled automatically.\n * @type {!Array<string>}\n */\nState.INVALID_KEYS = ['state', 'stateKey'];\n\n/**\n * Constants that represent the states that a state key can be in.\n * @type {!Object}\n */\nState.KeyStates = {\n\tUNINITIALIZED: 0,\n\tINITIALIZING: 1,\n\tINITIALIZED: 2\n};\n\nexport default State;\n"],"sourceRoot":"/source/"}